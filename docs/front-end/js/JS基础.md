[[toc]]

## 堆与栈

### 栈（stack）

栈的特点是**"LIFO，即后进先出（Last in, first out）"**。数据存储时只能从顶部逐个存入，取出时也需从顶部逐个取出。

比如一个乒乓球的盒子，先放进去（入栈）的乒乓球就只能后出来（出栈）。

### 堆（heap） 

堆的特点是**"无序"**的`key-value`**"键值对"**存储方式。
举个例子：书架存书

### 栈内存和堆内存存在原因 

**通常与垃圾回收机制有关。为了使程序运行时占用的内存最小。**

当一个方法执行时，每个方法都会建立自己的内存栈，在这个方法内定义的变量将会逐个放入这块栈内存里，随着方法的执行结束，这个方法的内存栈也将自然销毁了。

因此，**所有在方法中定义的变量都是放在栈内存中的；**

当我们在程序中创建一个对象时，这个对象将被保存到运行时数据区中，以便反复利用（因为对象的创建成本通常较大），这个运行时数据区就是堆内存。

**堆内存中的对象不会随方法的结束而销毁**，即使方法结束后，这个对象还可能被另一个引用变量所引用（方法的参数传递时很常见），则这个对象依然不会被销毁，只有当一个对象没有任何引用变量引用它时，系统的垃圾回收机制才会在核实的时候回收它。



## js代码运行机制

![js运行图](https://img.callbackhell.xyz/vuepress/js/js%E6%89%A7%E8%A1%8C%E6%B5%81%E7%A8%8B.png)

这是一张简单的JavaScript运行图，大致分为两个阶段，编译阶段和执行阶段。

### 编译阶段

- ### 分词/词法分析

  这个过程是将由字符组成的字符串分解为有意义的代码块，这些代码块我们称之为**词法单元（token）**。例如：var num = 1;在当前阶段会被分解为var、num、=、1、空格，每一个都是一个词法单元，当然空格是否是一个有效的词法单元取决于空格是否在JavaScript是否有意义。

- ### 解析/语法分析

    这个过程主要是将词法单元流（数组）转换为一个由元素嵌套的**程序语法树（抽象语法树，AST）。**

- ### 预解释/代码生成

  这个阶段主要是将AST转换为可执行代码。这个阶段会进行[变量的提升]。

### 执行阶段

1. ### 可执行代码

   JavaScript并不是简单的一行行解释执行，而是将JavaScript代码分为一块块的可执行代码块进行执行，JavaScript中主要主要分为**三类可执行代码**。

	- **全局可执行代码**
	- **函数可执行代码**
	- **Eval可执行代码**
	
2. ### 执行上下文

   简而言之，执行上下文是评估和执行 JavaScript 代码的环境的抽象概念。每当 Javascript 代码在运行的时候，它都是在执行上下文中运行。

   JavaScript中每一个可执行代码，在解释执行前，都会创建一个可执行上下文。按照可执行代码块可分为**三种可执行上下文类型**

   - 全局可执行上下文

     每一个程序都有一个全局可执行代码，并且只有一个。任何不在函数内部的代码都在全局执行上下文。

   - 函数可执行上下文

     每当一个函数被调用时, 都会为该函数创建一个新的上下文。每个函数都被调用时都会创建它自己的执行上下文。

   - Eval可执行上下文

     Eval也有自己执行上下文。

3. ### 执行上下文的创建

   - **this的指向**：除开箭头函数的this是编辑阶段确定的之外，其他this都是在代码执行阶段【代码执行阶段 === 执行上下文创建阶段】确认的。

   	```
   1、普通函数的调用：this指向window(浏览器环境)
   2、对象方法的调用：this指向调用对象
   3、构造函数：this指向构造函数实例
   4、apply、call、bind：this指向绑定值
   5、箭头函数this：this指向外层第一个普通函数调用的this
   	```

   - **创建词法环境**

     Lexical Environments（词法环境），之所以叫词法环境，是因为它是和源程序的结构对应，就是和你所写的那些源码的文字的结构对应，你写代码的时候这个环境就定了。
     
     词法环境**由两部分组成**：
     
     - Environment Records（环境记录）：这个就是变量登记的地方了

     - outer:outer 是个指向，包含（包围）本词法环境的外部词法环境
     
       outer很重要，它是作用域链能够链起来的关键(类似于原型链，指向外层上级环境)
     
     有三个主要的词法环境类型：
     
     
     1. **全局环境**(Global Environment)
     
        全局环境的外部环境outer引用是 null（因为他就是最外层），它拥有内建的 Object/Array/等、在环境记录器内的原型函数（关联全局对象，比如 window 对象）还有任何用户定义的全局变量，并且 this的值指向全局对象。
     
     2. **模块环境**
     
        包含模块顶级声明的绑定以及模块显式导入的绑定。 模块环境的外部环境是全局环境。
     
     3. **函数环境**
     
        函数内部用户定义的变量存储在环境记录器中，外部引用既可以是其它函数的内部词法环境，也可以是全局词法环境
     
     
     

4. ### JS引擎解析 

   一个JS引擎主要有一下几部分组成。

   - 编译器：负责JavaScript的语法分析和代码生成。
   - 解析器：在某些引擎中，解释器主要是接收字节码，解释执行这个字节码，同时也依赖垃圾回收机制等。
   - JIT：将字码节或者抽象语法树转换为本地可执行代码。
   - 垃圾回收，分析工具：负责垃圾回收和收集引擎中的信息，帮助改善引擎的性能和功效。

   

   > 参考：
   >
   > [js运行机制解析](https://juejin.cn/post/6844903943013662734#heading-8)
   >
   > [JS运行上下文解析](https://juejin.cn/post/6844903741607395336)

## 垃圾回收机制

JavaScript中有自动垃圾回收机制，会通过标记清除的算法识别哪些变量对象不再使用，对其进行销毁。**开发者也可在代码中手动设置变量值为null（`a = null`）进行标记清除**，让其失去引用，以便下一次垃圾回收时进行有效回收。

局部环境中，函数执行完成后，函数局部环境声明的变量不再需要时，就会被垃圾回收销毁（理想的情况下，闭包会阻止这一过程）。

全局环境只有页面退出时才会出栈，解除变量引用。所以开发者应尽量避免在全局环境中创建全局变量，如需使用，也要在不需要时手动标记清除，将其内存释放掉。