### 防抖

触发事件后不立即执行，在一定时间内如果再次触发，重新计时，计时结束后执行事件

```javascript
// 间隔时间 默认300ms
function debounce(fn, interval = 300) {
  let timer // 保存定时器变量
  return function() {
    timer && clearTimeout(timer) // 上一个定时器存在则清除，并重新计时
    const context = this // 保存上下文
    // 保存此处的arguments，因为setTimeout是全局的，arguments不是防抖函数需要的。
    const args = arguments
    // 开始计时
    timer = setTimeout(function() {
      fn.call(context, args)
    }, interval)
  }
}
```



### 节流

规定在一个单位时间内，只能触发一次函数。如果这个单位时间内触发多次函数，只有一次生效。

```javascript
 function throttle(fun, delay) {
        let last, deferTimer
        return function (args) {
            let that = this
            let _args = arguments
            let now = +new Date()
            if (last && now < last + delay) {
                clearTimeout(deferTimer)
                deferTimer = setTimeout(function () {
                    last = now
                    fun.apply(that, _args)
                }, delay)
            }else {
                last = now
                fun.apply(that,_args)
            }
        }
    }
```

### 浅拷贝

只遍历第一层

```javascript
function shadowClone(obj) {
  let cloneData = Array.isArray(obj) ? [] : {};
  for (let key in obj) {
    cloneData[key] = obj[key];
  }
  return cloneData;
}
```

### [#](https://www.weirshi.com/realize/realize-clone.html#深拷贝)深拷贝

简单实现，递归

```javascript
function deepClone(obj) {
  // 设置数据类型
  let cloneData = Array.isArray(obj) ? [] : {};
  if(obj && typeof obj === "object"){
    for(key in obj){
      if(obj.hasOwnProperty(key)){
        // 判断子元素是否为对象，如果是，递归复制
        if(obj[key] && typeof obj[key] === "object"){
          objClone[key] = deepClone(obj[key]);
        }else{
          // 如果不是，简单复制
          objClone[key] = obj[key];
        }
      }
    }
  }
  return cloneData;
}
```