<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>1.Promise | BLOG</title>
    <meta name="generator" content="VuePress 1.5.4">
    <link rel="icon" href="/vuepress/favicon.ico">
    <meta name="description" content="学习笔记">
    <link rel="preload" href="/vuepress/assets/css/0.styles.a1d845f0.css" as="style"><link rel="preload" href="/vuepress/assets/js/app.698edf64.js" as="script"><link rel="preload" href="/vuepress/assets/js/2.2ce5df5b.js" as="script"><link rel="preload" href="/vuepress/assets/js/34.4f154d4c.js" as="script"><link rel="prefetch" href="/vuepress/assets/js/10.09b2ea05.js"><link rel="prefetch" href="/vuepress/assets/js/11.c69ee5aa.js"><link rel="prefetch" href="/vuepress/assets/js/12.1f170326.js"><link rel="prefetch" href="/vuepress/assets/js/13.1883e67e.js"><link rel="prefetch" href="/vuepress/assets/js/14.55d29b4e.js"><link rel="prefetch" href="/vuepress/assets/js/15.b571d130.js"><link rel="prefetch" href="/vuepress/assets/js/16.cbf4423a.js"><link rel="prefetch" href="/vuepress/assets/js/17.0ecae00f.js"><link rel="prefetch" href="/vuepress/assets/js/18.8a452ec9.js"><link rel="prefetch" href="/vuepress/assets/js/19.0022a899.js"><link rel="prefetch" href="/vuepress/assets/js/20.e82790c5.js"><link rel="prefetch" href="/vuepress/assets/js/21.ef1a1af6.js"><link rel="prefetch" href="/vuepress/assets/js/22.c1aad3a2.js"><link rel="prefetch" href="/vuepress/assets/js/23.f403526b.js"><link rel="prefetch" href="/vuepress/assets/js/24.d3cc9450.js"><link rel="prefetch" href="/vuepress/assets/js/25.8f1830d8.js"><link rel="prefetch" href="/vuepress/assets/js/26.3a75cf4e.js"><link rel="prefetch" href="/vuepress/assets/js/27.e3af81ba.js"><link rel="prefetch" href="/vuepress/assets/js/28.c1867c81.js"><link rel="prefetch" href="/vuepress/assets/js/29.2ba9a3bd.js"><link rel="prefetch" href="/vuepress/assets/js/3.dfccb20d.js"><link rel="prefetch" href="/vuepress/assets/js/30.8ddcfe76.js"><link rel="prefetch" href="/vuepress/assets/js/31.7e828e57.js"><link rel="prefetch" href="/vuepress/assets/js/32.91359916.js"><link rel="prefetch" href="/vuepress/assets/js/33.b29c47e5.js"><link rel="prefetch" href="/vuepress/assets/js/35.25e2d8d4.js"><link rel="prefetch" href="/vuepress/assets/js/36.29df960a.js"><link rel="prefetch" href="/vuepress/assets/js/37.f9ec995f.js"><link rel="prefetch" href="/vuepress/assets/js/38.b100008f.js"><link rel="prefetch" href="/vuepress/assets/js/39.5794a728.js"><link rel="prefetch" href="/vuepress/assets/js/4.d599a372.js"><link rel="prefetch" href="/vuepress/assets/js/40.b4c2b4e9.js"><link rel="prefetch" href="/vuepress/assets/js/41.b79940a3.js"><link rel="prefetch" href="/vuepress/assets/js/42.48670cce.js"><link rel="prefetch" href="/vuepress/assets/js/43.9251067b.js"><link rel="prefetch" href="/vuepress/assets/js/44.d9be37b6.js"><link rel="prefetch" href="/vuepress/assets/js/45.e3dee9cd.js"><link rel="prefetch" href="/vuepress/assets/js/5.525c50d0.js"><link rel="prefetch" href="/vuepress/assets/js/6.386e2672.js"><link rel="prefetch" href="/vuepress/assets/js/7.d4dd4b8a.js"><link rel="prefetch" href="/vuepress/assets/js/8.f7bedf91.js"><link rel="prefetch" href="/vuepress/assets/js/9.721f3546.js">
    <link rel="stylesheet" href="/vuepress/assets/css/0.styles.a1d845f0.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div class="theme-container"><header class="navbar"><div class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div> <a href="/vuepress/" class="home-link router-link-active"><!----> <span class="site-name">BLOG</span></a> <div class="links"><div class="search-box"><input aria-label="Search" autocomplete="off" spellcheck="false" value=""> <!----></div> <nav class="nav-links can-hide"><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="前端学习笔记" class="dropdown-title"><span class="title">前端学习笔记</span> <span class="arrow down"></span></button> <button type="button" aria-label="前端学习笔记" class="mobile-dropdown-title"><span class="title">前端学习笔记</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/vuepress/front-end/evo/优化方式.html" class="nav-link">
  前端优化
</a></li><li class="dropdown-item"><!----> <a href="/vuepress/front-end/js/es6知识.html" class="nav-link">
  JS
</a></li><li class="dropdown-item"><!----> <a href="/vuepress/front-end/vue/vue知识点.html" class="nav-link">
  VUE
</a></li><li class="dropdown-item"><!----> <a href="/vuepress/front-end/webpack/webpack基础.html" class="nav-link">
  Webpack
</a></li><li class="dropdown-item"><!----> <a href="/vuepress/front-end/net/网络基础.html" class="nav-link">
  网络基础
</a></li><li class="dropdown-item"><!----> <a href="/vuepress/front-end/tools/GIT.html" class="nav-link">
  开发工具
</a></li><li class="dropdown-item"><!----> <a href="/vuepress/front-end/ci/travis自动部署.html" class="nav-link">
  前端自动化
</a></li></ul></div></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="后台学习笔记" class="dropdown-title"><span class="title">后台学习笔记</span> <span class="arrow down"></span></button> <button type="button" aria-label="后台学习笔记" class="mobile-dropdown-title"><span class="title">后台学习笔记</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/vuepress/back-end/node/express.html" class="nav-link">
  NodeJS
</a></li><li class="dropdown-item"><!----> <a href="/vuepress/back-end/lib-web/RESTful.html" class="nav-link">
  web开发知识
</a></li><li class="dropdown-item"><!----> <a href="/vuepress/back-end/server/Nginx.html" class="nav-link">
  服务器
</a></li></ul></div></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="JustDoIT" class="dropdown-title"><span class="title">JustDoIT</span> <span class="arrow down"></span></button> <button type="button" aria-label="JustDoIT" class="mobile-dropdown-title"><span class="title">JustDoIT</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/vuepress/funs/hardware/arduino.html" class="nav-link">
  硬件
</a></li></ul></div></div> <!----></nav></div></header> <div class="sidebar-mask"></div> <aside class="sidebar"><nav class="nav-links"><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="前端学习笔记" class="dropdown-title"><span class="title">前端学习笔记</span> <span class="arrow down"></span></button> <button type="button" aria-label="前端学习笔记" class="mobile-dropdown-title"><span class="title">前端学习笔记</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/vuepress/front-end/evo/优化方式.html" class="nav-link">
  前端优化
</a></li><li class="dropdown-item"><!----> <a href="/vuepress/front-end/js/es6知识.html" class="nav-link">
  JS
</a></li><li class="dropdown-item"><!----> <a href="/vuepress/front-end/vue/vue知识点.html" class="nav-link">
  VUE
</a></li><li class="dropdown-item"><!----> <a href="/vuepress/front-end/webpack/webpack基础.html" class="nav-link">
  Webpack
</a></li><li class="dropdown-item"><!----> <a href="/vuepress/front-end/net/网络基础.html" class="nav-link">
  网络基础
</a></li><li class="dropdown-item"><!----> <a href="/vuepress/front-end/tools/GIT.html" class="nav-link">
  开发工具
</a></li><li class="dropdown-item"><!----> <a href="/vuepress/front-end/ci/travis自动部署.html" class="nav-link">
  前端自动化
</a></li></ul></div></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="后台学习笔记" class="dropdown-title"><span class="title">后台学习笔记</span> <span class="arrow down"></span></button> <button type="button" aria-label="后台学习笔记" class="mobile-dropdown-title"><span class="title">后台学习笔记</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/vuepress/back-end/node/express.html" class="nav-link">
  NodeJS
</a></li><li class="dropdown-item"><!----> <a href="/vuepress/back-end/lib-web/RESTful.html" class="nav-link">
  web开发知识
</a></li><li class="dropdown-item"><!----> <a href="/vuepress/back-end/server/Nginx.html" class="nav-link">
  服务器
</a></li></ul></div></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="JustDoIT" class="dropdown-title"><span class="title">JustDoIT</span> <span class="arrow down"></span></button> <button type="button" aria-label="JustDoIT" class="mobile-dropdown-title"><span class="title">JustDoIT</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/vuepress/funs/hardware/arduino.html" class="nav-link">
  硬件
</a></li></ul></div></div> <!----></nav>  <ul class="sidebar-links"><li><section class="sidebar-group depth-0"><p class="sidebar-heading open"><span>JS</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/vuepress/front-end/js/es6知识.html" class="active sidebar-link">ES6</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/vuepress/front-end/js/es6知识.html#_1-promise" class="sidebar-link">1.Promise</a></li><li class="sidebar-sub-header"><a href="/vuepress/front-end/js/es6知识.html#_2-事件驱动" class="sidebar-link">2.事件驱动</a></li><li class="sidebar-sub-header"><a href="/vuepress/front-end/js/es6知识.html#_3-事件循环" class="sidebar-link">3.事件循环</a></li><li class="sidebar-sub-header"><a href="/vuepress/front-end/js/es6知识.html#_4-es6-运行环境" class="sidebar-link">4.ES6 运行环境</a></li><li class="sidebar-sub-header"><a href="/vuepress/front-end/js/es6知识.html#_5-模块系统" class="sidebar-link">5.模块系统</a></li><li class="sidebar-sub-header"><a href="/vuepress/front-end/js/es6知识.html#_6-proxy-reflect" class="sidebar-link">6.Proxy / Reflect</a></li><li class="sidebar-sub-header"><a href="/vuepress/front-end/js/es6知识.html#_7-es6-的优化-新增" class="sidebar-link">7.ES6 的优化/新增</a></li><li class="sidebar-sub-header"><a href="/vuepress/front-end/js/es6知识.html#_8-for-of" class="sidebar-link">8. for...of</a></li><li class="sidebar-sub-header"><a href="/vuepress/front-end/js/es6知识.html#interator-接口" class="sidebar-link">Interator 接口</a></li></ul></li></ul></section></li></ul> </aside> <main class="page"> <div class="theme-default-content content__default"><h2 id="_1-promise"><a href="#_1-promise" class="header-anchor">#</a> 1.Promise</h2> <p>先了解一下 Promise/a+规范内容：</p> <ol><li><p>这个 promise 有三种状态：</p> <p>Promise 的初始状态为 pending，它可以由此状态转换为 fulfilled（本文为了一致把此状态叫做 resolved）或者 rejected，一旦状态确定，就不可以再次转换为其它状态，状态确定的过程称为 settle</p></li> <li><p>then 方法返回一个新的 Promise，Promise 的 then 方法返回一个新的 Promise，而不是返回 this，此处在下文会有更多解释；</p></li> <li><p>只有一个 then 方法，并通过 then 调用，没有 catch，race，all 等方法，甚至没有构造函数；</p></li></ol> <h3 id="promise-的实现"><a href="#promise-的实现" class="header-anchor">#</a> Promise 的实现</h3> <p>因为他只是一个规范，所以在不同的框架或者平台下有不同的实现</p> <ul><li><p>Angular：$q 服务</p></li> <li><p>Node：q 模块，co，then</p></li> <li><p>Es6: Promise, yield</p></li> <li><p>Es7： async await</p></li></ul> <h3 id="解决痛点"><a href="#解决痛点" class="header-anchor">#</a> 解决痛点：</h3> <p>由于 JavaScript 语言特性是由事件驱动，所有程序都是单线程执行的（由浏览器决定）；</p> <p>所以在解决异步问题上，例如浏览器事件，都是通过<strong>回调函数</strong>来处理异步结果；</p> <p>当场景复杂多层嵌套后，就会形成所谓的<strong>回调地狱</strong>；</p> <p>为了解决这种问题，社区提出了一些解决方案，采用<strong>链式调用</strong>的方法来解决异步回调；</p> <p>也就是 Promise，并被加入 ES6 标准。</p> <h3 id="使用"><a href="#使用" class="header-anchor">#</a> 使用：</h3> <p>Promise 作为一个构造函数，使用<code>new</code>来创建实例，接受一个初始化函数作为参数；</p> <p>这个初始化函数有两个参数<code>resolve/reject</code>，可供调用<code>Promise</code>构造函数中的两个处理函数；</p> <div class="language- line-numbers-mode"><pre class="language-text"><code> const promise = new Promise((resolve, reject) =&gt; {
   resolve('fulfilled'); // 状态由 pending =&gt; fulfilled
 })
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div><p>resolve 返回出的结果，可以在<code>then</code>中进行结果处理；</p> <p><code>then()</code>其实是在为<code>Promise</code>中的 callback 注册回调函数，回调函数并没有直接执行，而是在 resolve 后才执行，所以可以获取结果进行处理；</p> <h3 id="链式调用"><a href="#链式调用" class="header-anchor">#</a> 链式调用：</h3> <p>链式调用里 then 中的函数一定要 return 一个结果或者一个新的 Promise 对象，</p> <p>才可以让之后的 then 回调接收。</p> <h3 id="原理"><a href="#原理" class="header-anchor">#</a> 原理：</h3> <p><code>then</code></p> <h3 id="示例"><a href="#示例" class="header-anchor">#</a> 示例：</h3> <div class="language- line-numbers-mode"><pre class="language-text"><code>https://www.jianshu.com/p/559d25c88670 复杂案例
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><h2 id="_2-事件驱动"><a href="#_2-事件驱动" class="header-anchor">#</a> 2.事件驱动</h2> <p>js 在浏览器端是单线程的，也注定是单线程，因为浏览器主要作为与用户的交互端；</p> <p>如果是多线程，可能会造成复杂的操作问题，例如两个线程同时操作同一个 DOM，那么浏览器会无法进行；</p> <p>从一诞生，JavaScript 就是单线程，这已经成了这门语言的核心特征，将来也不会改变；</p> <blockquote><p>-- 百科解释</p> <p>事件驱动程序设计（英语：Event-driven programming）是一种电脑程序设计模型。这种模型的程序运行流程是由用户的动作（如鼠标的按键，键盘的按键动作）或者是由其他程序的消息来决定的。</p> <p>相对于批处理程序设计（batch programming）而言，程序运行的流程是由程序员来决定。批量的程序设计在初级程序设计教学课程上是一种方式。然而，事件驱动程序设计这种设计模型是在交互程序（Interactive program）的情况下孕育而生的</p></blockquote> <h3 id="进程与线程"><a href="#进程与线程" class="header-anchor">#</a> 进程与线程</h3> <p>进程是操作系统分配资源和调度任务的基本单位，线程是建立在进程上的一次程序运行单位，一个进程上可以有多个线程。</p> <ol><li>浏览器线程
<ul><li>用户界面-包括地址栏、前进/后退按钮、书签菜单等</li> <li>浏览器引擎-在用户界面和呈现引擎之间传送指令(浏览器的主进程)</li> <li>渲染引擎，也被称为浏览器内核(浏览器渲染进程)</li> <li>一个插件对应一个进程(第三方插件进程)</li> <li>GPU 提高网页浏览的体验( GPU 进程)</li></ul></li> <li>浏览器渲染引擎
<ul><li>渲染引擎内部是多线程的，内部包含 ui 线程和 js 线程</li> <li>js 线程 ui 线程 这两个线程互斥的，目的就是为了保证不产生冲突。</li> <li>ui 线程会把更改的放到队列中，当 js 线程空闲下来的时候，ui 线程在继续渲染</li></ul></li> <li>js 单线程
<ul><li>js 是单线程，为什么呢？如果多个线程同时操作 DOM ，哪页面不会很混乱？这里所谓的单线程指的是主线程是单线程的,所以在 Node 中主线程依旧是单线程的。</li></ul></li> <li>webworker 多线程
<ul><li>它和 js 主线程不是平级的，主线程可以控制 webworker，但是 webworker 不能操作 DOM，不能获取 document，window</li></ul></li> <li>其他线程
<ul><li>浏览器事件触发线程(用来控制事件循环,存放 setTimeout、浏览器事件、ajax 的回调函数)</li> <li>定时触发器线程(setTimeout 定时器所在线程)</li> <li>异步 HTTP 请求线程(ajax 请求线程)</li></ul></li></ol> <blockquote><p>单线程特点是节约了内存,并且不需要在切换执行上下文。而且单线程不需要管锁的问题,所谓 锁，在 java 里才有锁的概念，所以我们不用细研究</p></blockquote> <h2 id="_3-事件循环"><a href="#_3-事件循环" class="header-anchor">#</a> 3.事件循环</h2> <p>事件循环的步骤：
（1）所有同步任务都在主线程上执行，形成一个执行栈（execution context stack）。
（2）主线程之外，还存在一个&quot;任务队列&quot;（task queue）。只要异步任务有了运行结果，就在&quot;任务队列&quot;之中放置一个事件。
（3）一旦&quot;执行栈&quot;中的所有同步任务执行完毕，系统就会读取&quot;任务队列&quot;，看看里面有哪些事件。那些对应的异步任务，于是结束等待状态，进入执行栈，开始执行。
（4）主线程不断重复上面的第三步。</p> <p>一个线程中，事件循环是唯一的，但是任务队列可以有多个;</p> <ul><li><p>任务队列又分为 macro-task（宏任务）和 micro-task（微任务）;</p></li> <li><p>macro-task 大概包括：</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>script（整体代码）,
setTimeout,
setInterval,
setImmediate,
I/O,
UI rendering;
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br></div></div></li> <li><p>micro-task 大概包括：</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>process.nextTick,
Promise,
Object.observe(已废弃),
MutationObserver(html5新特性)
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br></div></div></li> <li><p>事件循环的顺序，决定了 JavaScript 代码的执行顺序。它从 script(整体代码)开始第一次循环。之后全局上下文进入函数调用栈。直到调用栈清空(只剩全局)，然后执行所有的 micro-task。当所有可执行的 micro-task 执行完毕之后。循环再次从 macro-task 开始，找到其中一个任务队列执行完毕，然后再执行所有的 micro-task，这样一直循环下去。</p></li></ul> <h2 id="_4-es6-运行环境"><a href="#_4-es6-运行环境" class="header-anchor">#</a> 4.ES6 运行环境</h2> <p>虽然目前大部分主流浏览器都支持了 es6 语法，但仍不能保证所有用户浏览器都支持；</p> <p>所以我们需要使用<code>babel</code>来进行编译，让 ES5+的语法都能编译为 ES5 运行在所有浏览器上；</p> <p>起初是为了兼容性，但后来更多是为了让 es 规范可以更大刀阔斧的添加新特性，因为我们有编译！；</p> <p><code>tc39</code>渐进式的演进模式，浏览器根本跟不上新特性的步伐，而 babel 存在，可以让<code>tc39</code>没有包袱的前进。</p> <blockquote><h4 id="tc39-是什么-包括哪些人"><a href="#tc39-是什么-包括哪些人" class="header-anchor">#</a> TC39 是什么？包括哪些人？</h4> <p>「TC39」全称「Technical Committee 39」译为「第 39 号技术委员会」，是 Ecma 组织架构中的一部分。</p> <p>一个推动 JavaScript 发展的委员会，由各个主流浏览器厂商的代表构成。</p> <h4 id="tc39-这群人主要的工作是什么"><a href="#tc39-这群人主要的工作是什么" class="header-anchor">#</a> TC39 这群人主要的工作是什么？</h4> <p>制定 ECMAScript 标准，标准生成的流程，并实现。</p> <h4 id="ecma-是什么"><a href="#ecma-是什么" class="header-anchor">#</a> ECMA 是什么</h4> <p>ECMA 就是欧洲计算机制造协会的简称：<code>European Computer Manufacturers Association</code></p></blockquote> <h2 id="_5-模块系统"><a href="#_5-模块系统" class="header-anchor">#</a> 5.模块系统</h2> <h3 id="意义"><a href="#意义" class="header-anchor">#</a> 意义：</h3> <p>就是将一个复杂的程序，依据一定的规则(规范)封装成几个块(文件), 并进行组合在一起，通常只是向外部暴露一些接口(方法)与外部其它模块通信；</p> <p>本质是一种复杂度管理的手段技术。</p> <h3 id="实现方案"><a href="#实现方案" class="header-anchor">#</a> 实现方案：</h3> <ul><li><p><code>AMD/CMD</code></p> <p>AMD 作为模块加载器，可以在浏览器环境中异步加载多个模块，解决了<code>COMMONJS</code>同步加载模块的问题；</p> <p>使用<code>注入依赖</code>的思想，需要在引用模块的文件中写明依赖的模块；</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>//demo.js
(function(){
    //配置每个变量对应的模块路径
    require.config({
        paths: {
            m1: './modules/m1',
            m2: './modules/m2',
            jquery:'./jquery-3.3.1'
        }
    })
    require(['m2','jquery'],function(m2,$){
        m2.show(); //结果：m2-amd m1-amd
        $('body').css('backgroundColor','#000');
    })
})()
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br></div></div></li> <li><p><code>COMMONJS</code></p> <p><code>CommonJS</code>规范是 Node 独有的模块规范；</p> <p><code>CommonJS</code>规范加载模块是<strong>同步</strong>的，也就是说，只有加载完成，才能执行后面的操作。</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>// a.js
module.exports = {
    a: 1
}
// or
exports.a = 1

// b.js
var module = require('./a.js')
module.a // -&gt; log 1
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br></div></div></li> <li><p><code>ES6</code></p> <p>使用简单，静态化设计思想，编译时就可确定依赖关系；足以取代上述两种方案；</p> <p>目前需要<code>babal</code>编译；</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>// 导出
export function hello() { };
export default {
  // ...
};
// 导入
import { readFile } from 'fs';
import React from 'react';
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br></div></div></li></ul> <h3 id="总结"><a href="#总结" class="header-anchor">#</a> 总结：</h3> <p>模块化本质是在管理程序复杂度，JS 模块化的演进另一方面也说明了 Web 的能力在不断增强，Web 应用日趋复杂。</p> <p>相信未来 JS 的能力进一步提升，我们的开发效率也会更加高效。</p> <h2 id="_6-proxy-reflect"><a href="#_6-proxy-reflect" class="header-anchor">#</a> 6.Proxy / Reflect</h2> <p>两个都是 ES6 新增的 API，proxy 作用是可以用来定义对象各种基本操作的自定义行为；</p> <p>可以改变 JS 默认的一些语言行为，包括拦截默认的 get/set 等底层方法，使得 JS 的使用自由度更高</p> <p>也能相当于对象或函数的浅拷贝，修改 target，可以对响应的代理 proxy 自定义操作；</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>let target = { age: 18, name: 'Niko Bellic' }
let handlers = {
  get (target, property) {
    return `${property}: ${target[property]}`
  },
  set (target, property, value) {
    target[property] = value
  }
}
let proxy = new Proxy(target, handlers)

proxy.age = 19
console.log(target.age, proxy.age)   // 19,          age : 19
console.log(target.name, proxy.name) // Niko Bellic, name: Niko Bellic
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br></div></div><p>target 是源对象，你设置的<code>handler</code>，在修改 target 的同时可以自定义 proxy 的结果；</p> <p>例如上面例子中，<code>get</code>的 handler 中返回了拼接后的<code>${property}: ${target[property]}</code>，这个返回值其实返回给了 new 代理的 proxy 实例；</p> <p>打个比方就是：</p> <p>可以理解为，有一个很火的明星，开通了一个微博账号，这个账号非常活跃，回复粉丝、到处点赞之类的，但可能并不是真的由本人在维护的。
而是在背后有一个其他人 or 团队来运营，我们就可以称他们为代理人，因为他们发表的微博就代表了明星本人的意思。</p> <p>这个<strong>代理运营团队</strong>就是<code>proxy</code>， 而明星<strong>本人</strong>就是<code>target</code>；</p> <h3 id="reflect"><a href="#reflect" class="header-anchor">#</a> Reflect</h3> <p>Reflect 是 ES6 引入的一个新的对象，</p> <p><strong>他的主要作用有两点</strong>，一是将原生的一些零散分布在 Object、Function 或者全局函数里的方法(如 apply、delete、get、set 等等)，统一整合到 Reflect 上，这样可以更加方便更加统一的管理一些原生 API。</p> <p>其次就是因为 Proxy 可以改写默认的原生 API，如果一旦原生 API 别改写可能就找不到了，所以 Reflect 也可以起到备份原生 API 的作用，使得即使原生 API 被改写了之后，也可以在被改写之后的 API 用上默认的 API。</p> <h2 id="_7-es6-的优化-新增"><a href="#_7-es6-的优化-新增" class="header-anchor">#</a> 7.ES6 的优化/新增</h2> <h3 id="string"><a href="#string" class="header-anchor">#</a> String</h3> <ul><li>模板字符串</li> <li>String.includes()</li></ul> <h3 id="array"><a href="#array" class="header-anchor">#</a> Array</h3> <ul><li>解构赋值</li> <li>扩展运算符</li> <li>Array.find()</li></ul> <h3 id="object"><a href="#object" class="header-anchor">#</a> Object</h3> <ul><li><p>对象解构赋值</p></li> <li><p>变量式声明属性</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>let es5Fun = {
    method: function(){}
};
let es6Fun = {
    method(){}
}
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br></div></div></li> <li><p>扩展运算符</p></li> <li><p>Object.assign()</p></li> <li><p>Object.keys()</p></li></ul> <h3 id="function"><a href="#function" class="header-anchor">#</a> Function</h3> <ul><li><p>箭头函数</p> <p><strong>箭头函数内的 this 指向的是函数定义时所在的对象，而不是函数执行时所在的对象</strong></p> <p>ES5 函数里的 this 总是指向函数执行时所在的对象，这使得在很多情况下 this 的指向变得很难理解，尤其是非严格模式情况下，this 有时候会指向全局对象，这甚至也可以归结为语言层面的 bug 之一</p></li> <li></li></ul> <h3 id="number"><a href="#number" class="header-anchor">#</a> Number</h3> <ul><li>优化 Number.isNaN()</li></ul> <h3 id="symbol"><a href="#symbol" class="header-anchor">#</a> Symbol</h3> <p>Symbol 是 ES6 引入的第七种原始数据类型,所有 Symbol()生成的值都是<strong>独一无二</strong>的</p> <p>可以从根本上解决对象属性太多导致<strong>属性名冲突</strong>覆盖的问题。对象中 Symbol()属性<strong>不能被 for...in 遍历</strong></p> <h3 id="set"><a href="#set" class="header-anchor">#</a> Set</h3> <p><strong>解决痛点：轻松去重，效率提升</strong></p> <p>Set 是 ES6 引入的一种<strong>类似 Array</strong>的新的数据结构，Set 实例的成员类似于数组 item 成员，区别是 Set 实例的成员都是<strong>唯一</strong>，不重复的。这个特性可以轻松地实现数组去重。</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>const duplicateCollection = ['A', 'B', 'B', 'C', 'D', 'B', 'C'];
// 将数组转换为 Set
let uniqueCollection = new Set(duplicateCollection);
console.log(uniqueCollection) // Result: Set(4) {&quot;A&quot;, &quot;B&quot;, &quot;C&quot;, &quot;D&quot;}
// 值保存在数组中
let uniqueCollection = [...new Set(duplicateCollection)];
console.log(uniqueCollection) // Result: [&quot;A&quot;, &quot;B&quot;, &quot;C&quot;, &quot;D&quot;]
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br></div></div><p>相比 Array 来说，Set 操作效率更高，方法更简洁；</p> <p>因为和 Array 相比之下，<code>set</code>是一个键的集合。<code>set</code>不使用索引，而是使用键对数据排序。</p> <p><code>set</code> 中的元素按插入顺序是可迭代的，它不能包含任何重复的数据。换句话说，<code>set</code>中的每一项都必须是惟一的。</p> <p><code>set</code> 相对于数组有几个优势，特别是在运行时间方面：</p> <ul><li><strong>查看元素</strong>：使用<code>indexOf()</code>或<code>includes()</code>检查数组中的项是否存在是比较慢的。</li> <li><strong>删除元素</strong>:在<code>Set</code>中，可以根据每项的的 <code>value</code> 来删除该项。在数组中，等价的方法是使用基于元素的索引的<code>splice()</code>。与前一点一样，依赖于索引的速度很慢。</li> <li><strong>保存 NaN</strong>：不能使用<code>indexOf()</code>或 <code>includes()</code> 来查找值 <code>NaN</code>，而 <code>Set</code> 可以保存此值。</li> <li><strong>删除重复项</strong>:<code>Set</code>对象只存储惟一的值,如果不想有重复项存在，相对于数组的一个显著优势，因为数组需要额外的代码来处理重复。</li></ul> <h3 id="map"><a href="#map" class="header-anchor">#</a> Map</h3> <p>解决痛点：<strong>key 值不限于 string，有序排列，统一遍历方法，API 方便</strong></p> <p>Map 是 ES6 引入的一种<strong>类似 Object</strong>的新的数据结构，Map 可以理解为是<strong>Object 的超集</strong>，打破了以传统键值对形式定义对象，<strong>对象的 key 不再局限于字符串</strong>，也可以是 Object。可以更加全面的描述对象的属性。</p> <ul><li>一个<code>Object</code> 的键只能是字符串或者 <code>Symbols</code>，但一个<code>Map</code> 的键可以是任意值。</li> <li><code>Map</code>中的键值是<strong>有序的</strong>（FIFO 先进先出原则），而添加到对象中的键则不是。</li> <li><code>Map</code>的键值对个数可以从 size 属性获取，而 <code>Object</code> 的键值对个数只能手动计算。</li> <li>合并两个 Map 对象时，如果有重复的键值，则<strong>后面的会覆盖前面</strong>的。</li></ul> <h2 id="_8-for-of"><a href="#_8-for-of" class="header-anchor">#</a> 8. for...of</h2> <h3 id="解决痛点-2"><a href="#解决痛点-2" class="header-anchor">#</a> 解决痛点：</h3> <p>Iterator 接口的目的就是为所有数据结构，<strong>提供了一种统一的访问机制</strong>，即<code>for...of</code>循环。</p> <p>当使用<code>for...of</code>循环遍历某种数据结构时，该循环会自动去寻找 Iterator 接口。</p> <p>一个数据结构只要部署了<code>Symbol.iterator</code>属性，就被视为具有 iterator 接口，就可以用 for...of 循环遍历它的成员。</p> <p>也就是说，for...of 循环内部调用的是数据结构的<code>Symbol.iterator</code>方法。</p> <p><strong>Iterator 接口主要供 for...of 消费， 且 for...of 循环需要有<code>iterator接口</code>。</strong></p> <div class="language- line-numbers-mode"><pre class="language-text"><code>// 模拟Iterator接口

let it = makeIterator(['a','b']);

it.next();// { value: &quot;a&quot;, done: false }
it.next();// { value: &quot;b&quot;, done: false }
it.next();// { value: undefined, done: true }

fucntion makeIterator(array){
    let nextIndex = 0;
    return {
        next : function(){
            return nextInedx &lt; array.length ?
            {value : array[nextIndex++], done : false} :
            {value : undefined, done : true};
        }
    }
}
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br></div></div><h2 id="interator-接口"><a href="#interator-接口" class="header-anchor">#</a> Interator 接口</h2> <p>Iterator 是 ES6 中一个很重要概念，它并不是对象，也不是任何一种数据类型。</p> <p>因为 ES6 新增了 Set、Map 类型，他们和 Array、Object 类型很像，Array、Object 都是可以遍历的，但是 Set、Map 都不能用 for 循环遍历；</p> <p>所以为了统一所有可遍历类型的遍历方式，Interator 就是这样一种标准；</p> <h3 id="原生接口"><a href="#原生接口" class="header-anchor">#</a> 原生接口</h3> <p>ES6 的有些数据结构原生具备 Iterator 接口（比如数组），即不用任何处理，就可以被 for...of 循环遍历。</p> <p>具备原生接口的类型：</p> <ul><li>Array</li> <li>Map</li> <li>Set</li> <li>String</li> <li>TypedArray</li> <li>函数的 arguments 对象</li> <li>NodeList 对象</li></ul> <p>以上类型可以原生使用<code>for...of</code>循环，但不包括对象<code>Object</code>，所以对象使用就需要手动添加<code>Iterator</code>接口；</p></div> <footer class="page-edit"><!----> <!----></footer> <!----> </main></div><div class="global-ui"></div></div>
    <script src="/vuepress/assets/js/app.698edf64.js" defer></script><script src="/vuepress/assets/js/2.2ce5df5b.js" defer></script><script src="/vuepress/assets/js/34.4f154d4c.js" defer></script>
  </body>
</html>
