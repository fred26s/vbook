<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>vue 源码结构 | BLOG</title>
    <meta name="generator" content="VuePress 1.7.1">
    <link rel="icon" href="/vbook/favicon.ico">
    <meta name="description" content="学习笔记">
    
    <link rel="preload" href="/vbook/assets/css/0.styles.5726f3cc.css" as="style"><link rel="preload" href="/vbook/assets/js/app.64803a45.js" as="script"><link rel="preload" href="/vbook/assets/js/2.dceffa7a.js" as="script"><link rel="preload" href="/vbook/assets/js/43.fdc58166.js" as="script"><link rel="prefetch" href="/vbook/assets/js/10.c8b41500.js"><link rel="prefetch" href="/vbook/assets/js/11.28c79869.js"><link rel="prefetch" href="/vbook/assets/js/12.602d258e.js"><link rel="prefetch" href="/vbook/assets/js/13.5225f803.js"><link rel="prefetch" href="/vbook/assets/js/14.86b3e846.js"><link rel="prefetch" href="/vbook/assets/js/15.020c6177.js"><link rel="prefetch" href="/vbook/assets/js/16.a5de8ab6.js"><link rel="prefetch" href="/vbook/assets/js/17.d4b4394b.js"><link rel="prefetch" href="/vbook/assets/js/18.5ac69d76.js"><link rel="prefetch" href="/vbook/assets/js/19.3ebe5320.js"><link rel="prefetch" href="/vbook/assets/js/20.ba80d828.js"><link rel="prefetch" href="/vbook/assets/js/21.993ca315.js"><link rel="prefetch" href="/vbook/assets/js/22.79c4804a.js"><link rel="prefetch" href="/vbook/assets/js/23.71cd2d95.js"><link rel="prefetch" href="/vbook/assets/js/24.1713254d.js"><link rel="prefetch" href="/vbook/assets/js/25.ee58070b.js"><link rel="prefetch" href="/vbook/assets/js/26.7d9e9d4c.js"><link rel="prefetch" href="/vbook/assets/js/27.77f61c94.js"><link rel="prefetch" href="/vbook/assets/js/28.04024ee9.js"><link rel="prefetch" href="/vbook/assets/js/29.5bcff1cd.js"><link rel="prefetch" href="/vbook/assets/js/3.3423f2fc.js"><link rel="prefetch" href="/vbook/assets/js/30.d1ca5e75.js"><link rel="prefetch" href="/vbook/assets/js/31.64668596.js"><link rel="prefetch" href="/vbook/assets/js/32.0b2d1e6f.js"><link rel="prefetch" href="/vbook/assets/js/33.5a061f89.js"><link rel="prefetch" href="/vbook/assets/js/34.2e3c7ab2.js"><link rel="prefetch" href="/vbook/assets/js/35.7218c247.js"><link rel="prefetch" href="/vbook/assets/js/36.60fc61bd.js"><link rel="prefetch" href="/vbook/assets/js/37.a14c1b7b.js"><link rel="prefetch" href="/vbook/assets/js/38.df2691ed.js"><link rel="prefetch" href="/vbook/assets/js/39.463ecbf5.js"><link rel="prefetch" href="/vbook/assets/js/4.d9efc253.js"><link rel="prefetch" href="/vbook/assets/js/40.f16d5670.js"><link rel="prefetch" href="/vbook/assets/js/41.65ce97f3.js"><link rel="prefetch" href="/vbook/assets/js/42.ccd3754e.js"><link rel="prefetch" href="/vbook/assets/js/44.aa0425dc.js"><link rel="prefetch" href="/vbook/assets/js/45.28e1b46e.js"><link rel="prefetch" href="/vbook/assets/js/46.9f678d14.js"><link rel="prefetch" href="/vbook/assets/js/47.5f63502f.js"><link rel="prefetch" href="/vbook/assets/js/48.07651b39.js"><link rel="prefetch" href="/vbook/assets/js/5.6b3bdc86.js"><link rel="prefetch" href="/vbook/assets/js/6.c9f44ce5.js"><link rel="prefetch" href="/vbook/assets/js/7.c95ece88.js"><link rel="prefetch" href="/vbook/assets/js/8.e5718fb1.js"><link rel="prefetch" href="/vbook/assets/js/9.ba545b0a.js">
    <link rel="stylesheet" href="/vbook/assets/css/0.styles.5726f3cc.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div class="theme-container"><header class="navbar"><div class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div> <a href="/vbook/" class="home-link router-link-active"><!----> <span class="site-name">BLOG</span></a> <div class="links"><div class="search-box"><input aria-label="Search" autocomplete="off" spellcheck="false" value=""> <!----></div> <nav class="nav-links can-hide"><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="前端学习笔记" class="dropdown-title"><span class="title">前端学习笔记</span> <span class="arrow down"></span></button> <button type="button" aria-label="前端学习笔记" class="mobile-dropdown-title"><span class="title">前端学习笔记</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/vbook/front-end/evo/优化方式.html" class="nav-link">
  前端优化
</a></li><li class="dropdown-item"><!----> <a href="/vbook/front-end/js/es6知识.html" class="nav-link">
  JS
</a></li><li class="dropdown-item"><!----> <a href="/vbook/front-end/vue/vue知识点.html" class="nav-link">
  VUE
</a></li><li class="dropdown-item"><!----> <a href="/vbook/front-end/webpack/webpack基础.html" class="nav-link">
  Webpack
</a></li><li class="dropdown-item"><!----> <a href="/vbook/front-end/net/网络基础.html" class="nav-link">
  网络基础
</a></li><li class="dropdown-item"><!----> <a href="/vbook/front-end/tools/GIT.html" class="nav-link">
  开发工具
</a></li><li class="dropdown-item"><!----> <a href="/vbook/front-end/ci/travis自动部署.html" class="nav-link">
  前端自动化
</a></li></ul></div></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="后台学习笔记" class="dropdown-title"><span class="title">后台学习笔记</span> <span class="arrow down"></span></button> <button type="button" aria-label="后台学习笔记" class="mobile-dropdown-title"><span class="title">后台学习笔记</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/vbook/back-end/node/express.html" class="nav-link">
  NodeJS
</a></li><li class="dropdown-item"><!----> <a href="/vbook/back-end/lib-web/RESTful.html" class="nav-link">
  web开发知识
</a></li><li class="dropdown-item"><!----> <a href="/vbook/back-end/server/Nginx.html" class="nav-link">
  服务器
</a></li></ul></div></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="JustDoIT" class="dropdown-title"><span class="title">JustDoIT</span> <span class="arrow down"></span></button> <button type="button" aria-label="JustDoIT" class="mobile-dropdown-title"><span class="title">JustDoIT</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/vbook/funs/hardware/arduino.html" class="nav-link">
  硬件
</a></li></ul></div></div> <!----></nav></div></header> <div class="sidebar-mask"></div> <aside class="sidebar"><nav class="nav-links"><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="前端学习笔记" class="dropdown-title"><span class="title">前端学习笔记</span> <span class="arrow down"></span></button> <button type="button" aria-label="前端学习笔记" class="mobile-dropdown-title"><span class="title">前端学习笔记</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/vbook/front-end/evo/优化方式.html" class="nav-link">
  前端优化
</a></li><li class="dropdown-item"><!----> <a href="/vbook/front-end/js/es6知识.html" class="nav-link">
  JS
</a></li><li class="dropdown-item"><!----> <a href="/vbook/front-end/vue/vue知识点.html" class="nav-link">
  VUE
</a></li><li class="dropdown-item"><!----> <a href="/vbook/front-end/webpack/webpack基础.html" class="nav-link">
  Webpack
</a></li><li class="dropdown-item"><!----> <a href="/vbook/front-end/net/网络基础.html" class="nav-link">
  网络基础
</a></li><li class="dropdown-item"><!----> <a href="/vbook/front-end/tools/GIT.html" class="nav-link">
  开发工具
</a></li><li class="dropdown-item"><!----> <a href="/vbook/front-end/ci/travis自动部署.html" class="nav-link">
  前端自动化
</a></li></ul></div></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="后台学习笔记" class="dropdown-title"><span class="title">后台学习笔记</span> <span class="arrow down"></span></button> <button type="button" aria-label="后台学习笔记" class="mobile-dropdown-title"><span class="title">后台学习笔记</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/vbook/back-end/node/express.html" class="nav-link">
  NodeJS
</a></li><li class="dropdown-item"><!----> <a href="/vbook/back-end/lib-web/RESTful.html" class="nav-link">
  web开发知识
</a></li><li class="dropdown-item"><!----> <a href="/vbook/back-end/server/Nginx.html" class="nav-link">
  服务器
</a></li></ul></div></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="JustDoIT" class="dropdown-title"><span class="title">JustDoIT</span> <span class="arrow down"></span></button> <button type="button" aria-label="JustDoIT" class="mobile-dropdown-title"><span class="title">JustDoIT</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/vbook/funs/hardware/arduino.html" class="nav-link">
  硬件
</a></li></ul></div></div> <!----></nav>  <ul class="sidebar-links"><li><section class="sidebar-group depth-0"><p class="sidebar-heading open"><span>Vue2.x</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/vbook/front-end/vue/vue知识点.html" class="sidebar-link">vue知识点</a></li><li><a href="/vbook/front-end/vue/vue源码-解读.html" class="active sidebar-link">vue源码-解读</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/vbook/front-end/vue/vue源码-解读.html#vue-源码结构" class="sidebar-link">vue 源码结构</a></li><li class="sidebar-sub-header"><a href="/vbook/front-end/vue/vue源码-解读.html#compiler" class="sidebar-link">compiler</a></li><li class="sidebar-sub-header"><a href="/vbook/front-end/vue/vue源码-解读.html#core" class="sidebar-link">core</a></li><li class="sidebar-sub-header"><a href="/vbook/front-end/vue/vue源码-解读.html#server" class="sidebar-link">server</a></li><li class="sidebar-sub-header"><a href="/vbook/front-end/vue/vue源码-解读.html#platforms" class="sidebar-link">platforms</a></li><li class="sidebar-sub-header"><a href="/vbook/front-end/vue/vue源码-解读.html#sfc" class="sidebar-link">sfc</a></li><li class="sidebar-sub-header"><a href="/vbook/front-end/vue/vue源码-解读.html#shared" class="sidebar-link">shared</a></li><li class="sidebar-sub-header"><a href="/vbook/front-end/vue/vue源码-解读.html#入口文件" class="sidebar-link">入口文件</a></li><li class="sidebar-sub-header"><a href="/vbook/front-end/vue/vue源码-解读.html#初始化" class="sidebar-link">初始化</a></li><li class="sidebar-sub-header"><a href="/vbook/front-end/vue/vue源码-解读.html#依赖收集" class="sidebar-link">依赖收集</a></li><li class="sidebar-sub-header"><a href="/vbook/front-end/vue/vue源码-解读.html#compile-编译模板" class="sidebar-link">compile 编译模板</a></li><li class="sidebar-sub-header"><a href="/vbook/front-end/vue/vue源码-解读.html#observe-响应式化" class="sidebar-link">observe 响应式化</a></li><li class="sidebar-sub-header"><a href="/vbook/front-end/vue/vue源码-解读.html#响应式实现" class="sidebar-link">响应式实现</a></li><li class="sidebar-sub-header"><a href="/vbook/front-end/vue/vue源码-解读.html#异步更新和-nexttick" class="sidebar-link">异步更新和 nextTick</a></li><li class="sidebar-sub-header"><a href="/vbook/front-end/vue/vue源码-解读.html#nexttick" class="sidebar-link">nextTick</a></li></ul></li><li><a href="/vbook/front-end/vue/vue源码-总结.html" class="sidebar-link">vue源码-总结</a></li></ul></section></li></ul> </aside> <main class="page"> <div class="theme-default-content content__default"><h2 id="vue-源码结构"><a href="#vue-源码结构" class="header-anchor">#</a> vue 源码结构</h2> <div class="language- line-numbers-mode"><pre class="language-text"><code>├── scripts ------------------------------- 包含与构建相关的脚本和配置文件
│   ├── alias.js -------------------------- 源码中使用到的模块导入别名
│   ├── config.js ------------------------- 项目的构建配置
├── build --------------------------------- 构建相关的文件，一般情况下我们不需要动
├── dist ---------------------------------- 构建后文件的输出目录
├── examples ------------------------------ 存放一些使用Vue开发的应用案例
├── flow ---------------------------------- JS静态类型检查工具 [Flow](https://flowtype.org/) 的类型声明
├── package.json
├── test ---------------------------------- 测试文件
├── src ----------------------------------- 源码目录
│   ├── compiler -------------------------- 编译器代码，用来将 template 编译为 render 函数
│   │   ├── parser ------------------------ 存放将模板字符串转换成元素抽象语法树的代码
│   │   ├── codegen ----------------------- 存放从抽象语法树(AST)生成render函数的代码
│   │   ├── optimizer.js ------------------ 分析静态树，优化vdom渲染
│   ├── core ------------------------------ 存放通用的，平台无关的运行时代码
│   │   ├── observer ---------------------- 响应式实现，包含数据观测的核心代码
│   │   ├── vdom -------------------------- 虚拟DOM的 creation 和 patching 的代码
│   │   ├── instance ---------------------- Vue构造函数与原型相关代码
│   │   ├── global-api -------------------- 给Vue构造函数挂载全局方法(静态方法)或属性的代码
│   │   ├── components -------------------- 包含抽象出来的通用组件，目前只有keep-alive
│   ├── server ---------------------------- 服务端渲染(server-side rendering)的相关代码
│   ├── platforms ------------------------- 不同平台特有的相关代码
│   │   ├── weex -------------------------- weex平台支持
│   │   ├── web --------------------------- web平台支持
│   │   │   ├── entry-runtime.js ---------------- 运行时构建的入口
│   │   │   ├── entry-runtime-with-compiler.js -- 独立构建版本的入口
│   │   │   ├── entry-compiler.js --------------- vue-template-compiler 包的入口文件
│   │   │   ├── entry-server-renderer.js -------- vue-server-renderer 包的入口文件
│   ├── sfc ------------------------------- 包含单文件组件(.vue文件)的解析逻辑，用于vue-template-compiler包
│   ├── shared ---------------------------- 整个代码库通用的代码
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br><span class="line-number">24</span><br><span class="line-number">25</span><br><span class="line-number">26</span><br><span class="line-number">27</span><br><span class="line-number">28</span><br><span class="line-number">29</span><br><span class="line-number">30</span><br></div></div><p>源码结构主要分为 5 大块：</p> <ul><li><h2 id="compiler"><a href="#compiler" class="header-anchor">#</a> compiler</h2> <p>编译器代码，用来将 template 编译为 render 函数</p></li> <li><h2 id="core"><a href="#core" class="header-anchor">#</a> core</h2> <p>核心代码。存放通用的，平台无关的运行时代码</p></li> <li><h2 id="server"><a href="#server" class="header-anchor">#</a> server</h2> <p>服务端渲染(server-side rendering)的相关代码</p></li> <li><h2 id="platforms"><a href="#platforms" class="header-anchor">#</a> platforms</h2> <p>跨平台实现代码</p></li> <li><h2 id="sfc"><a href="#sfc" class="header-anchor">#</a> sfc</h2> <p>.vue 文件的解析逻辑，用于 vue-template-compiler</p></li> <li><h2 id="shared"><a href="#shared" class="header-anchor">#</a> shared</h2> <p>整个代码库通用的代码</p></li></ul> <p><img src="//img.joyfred.com/vuepress/vue/vue%E8%A7%A3%E6%9E%90%E6%B5%81%E7%A8%8B.png" alt="vue解析流程"></p> <h2 id="入口文件"><a href="#入口文件" class="header-anchor">#</a> 入口文件</h2> <p>可以看到<code>package.json</code>中脚本 script，使用到了<code>rollup</code>:</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>&quot;scripts&quot;: {
    &quot;dev&quot;: &quot;rollup -w -c scripts/config.js --environment TARGET:web-full-dev&quot;,
    &quot;build&quot;: &quot;node scripts/build.js&quot;,
}
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br></div></div><p>看到<code>dev</code>是使用<code>rollup</code>打包库进行模块处理，执行的文件是<code>scripts/config.js</code>;</p> <p>进入到这个 config.js 中，看到最下面一行：</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>if (process.env.TARGET) {
  module.exports = genConfig(process.env.TARGET)
} else {
  exports.getBuild = genConfig
  exports.getAllBuilds = () =&gt; Object.keys(builds).map(genConfig)
}

</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br></div></div><p>能看到通过全局环境变量<code>TARGET</code>来判断了获取的配置参数；</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>function genConfig (name) {
  const opts = builds[name]
	..... // 使用配置
}

const builds = {
  // Runtime+compiler development build (Browser)
  'web-full-dev': {
    entry: resolve('web/entry-runtime-with-compiler.js'),   // 入口文件
    dest: resolve('dist/vue.js'), // 输出文件
    format: 'umd',
    env: 'development',
    alias: { he: './entity-decoder' },
    banner
  },
}
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br></div></div><p>可以看到打包的入口文件为<code>web/entry-runtime-with-compiler.js</code>;</p> <p>这里可以看到实际就是跑了上面项目结构中<code>platforms - web - entry-runtime-with-compiler.js</code>的 web 平台实现代码；</p> <p>再通过这个 runtime 文件中，可以找到<code>Vue</code>的初始化构造函数文件，</p> <p>在<code>src/core/instance/index.js</code>,这里不赘述，看了源码就可以找到；</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>import { initMixin } from './init'
import { stateMixin } from './state'
import { renderMixin } from './render'
import { eventsMixin } from './events'
import { lifecycleMixin } from './lifecycle'
import { warn } from '../util/index'

function Vue (options) {
  if (process.env.NODE_ENV !== 'production' &amp;&amp;
    !(this instanceof Vue)
  ) {
    warn('Vue is a constructor and should be called with the `new` keyword')
  }
  this._init(options)  // 初始化
}

// 初始化挂在Vue.prototype上各种属性方法
initMixin(Vue)         // 给Vue.prototype添加：_init函数,...
stateMixin(Vue)        // 给Vue.prototype添加：$data属性, $props属性, $set函数, $delete函数, $watch函数,...
eventsMixin(Vue)       // 给Vue.prototype添加：$on函数, $once函数, $off函数, $emit函数, $watch方法,...
lifecycleMixin(Vue)    // 给Vue.prototype添加: _update方法, $forceUpdate函数, $destroy函数,...
renderMixin(Vue)       // 给Vue.prototype添加: $nextTick函数, _render函数,...

</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br></div></div><h2 id="初始化"><a href="#初始化" class="header-anchor">#</a> 初始化</h2> <p>vue 通过在入口文件上挂在 Vue 实例所需的属性和方法，包括一个<code>_init</code>初始化方法；</p> <p>在<code>_init</code>方法中，初始化生命周期、实例属性、事件、watch 监听、调用<code>beforeCreate/ created</code>钩子；</p> <p>最后调用了<code>vm.$mount</code>事件； 实现页面挂载调用；</p> <p>这个<code>$mount</code>事件根据不同平台都有各自的定义实现，我们关注 web 平台的实现：</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>//-- src\platforms\web\runtime\index.js --//

import { mountComponent } from 'core/instance/lifecycle'
// public mount method
Vue.prototype.$mount = function (
  el?: string | Element,
  hydrating?: boolean
): Component {
  el = el &amp;&amp; inBrowser ? query(el) : undefined
  return mountComponent(this, el, hydrating)        // 实际上就是调用了这个mountComponent()
}

</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br></div></div><p>而 mountComponent 做了什么？</p> <p>这个方法中调用了<code>beforeMount / mounted</code>钩子函数，</p> <p>并且实例化了一个<code>Watcher</code>，用来监听数据更新，并实时调用<code>beforeUpdate</code>;</p> <p>可以在<code>// src/core/instance/lifecycle.js</code>中详细阅读源码；</p> <h2 id="依赖收集"><a href="#依赖收集" class="header-anchor">#</a> 依赖收集</h2> <h2 id="compile-编译模板"><a href="#compile-编译模板" class="header-anchor">#</a> compile 编译模板</h2> <p>挂载的 DOM 节点，如 template 模板文件中写的 HTML，都会被<code>compile</code>函数转换为<code>render</code>函数，来让浏览器识别；</p> <p>看一下<code>compile</code>如何实现：</p> <p>入口文件在：<code>src/platform/web/entry-runtime-with-compiler.js</code>;</p> <p>追踪其中的``compileToFunctions<code></code>方法，可以找到定义该编译方法的文件在<code>src/compiler/index.js</code>;</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>export const createCompiler = createCompilerCreator(function baseCompile (
  template: string,
  options: CompilerOptions
): CompiledResult {
  const ast = parse(template.trim(), options)    // 解析HTML
  if (options.optimize !== false) {
    optimize(ast, options)                    // 优化AST
  }
  const code = generate(ast, options)       // 生成render函数
  return {
    ast,
    render: code.render,
    staticRenderFns: code.staticRenderFns
  }
})
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br></div></div><p>这里可以看到有三个重要的过程 <code>parse</code>、<code>optimize</code>、<code>generate</code>，之后生成了 render 方法代码。</p> <ul><li><code>parse</code>：会用正则等方式解析 template 模板中的指令、class、style 等数据，形成抽象语法树 AST</li> <li><code>optimize</code>：优化 AST，生成模板 AST 树，检测不需要进行 DOM 改变的静态子树，减少 patch 的压力</li> <li><code>generate</code>：把 AST 生成 render 方法的代码</li></ul> <h2 id="observe-响应式化"><a href="#observe-响应式化" class="header-anchor">#</a> observe 响应式化</h2> <p>Vue 中的数据响应式是通过<code>Object.defineProperty</code>来实现的；</p> <p>代码实现是在<code>this._init</code>的初始化代码中，<code>initState()</code>部分的代码；</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>// src/core/instance/state.js

export function initState(vm: Component) {
  vm._watchers = []
  const opts = vm.$options
  if (opts.props) initProps(vm, opts.props)
  if (opts.methods) initMethods(vm, opts.methods)
  if (opts.data) {
    initData(vm)                      // 初始化data数据
  } else {
    observe(vm._data = {}, true /* asRootData */)
  }
  if (opts.computed) initComputed(vm, opts.computed)
  if (opts.watch &amp;&amp; opts.watch !== nativeWatch) {
    initWatch(vm, opts.watch)
  }
}

....
function initData(vm: Component) {
  let data = vm.$options.data
  data = vm._data = typeof data === 'function'
                    ? getData(data, vm)
                    : data || {}

  observe(data, true /* asRootData */) // 给data做响应式处理
}

</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br><span class="line-number">24</span><br><span class="line-number">25</span><br><span class="line-number">26</span><br><span class="line-number">27</span><br><span class="line-number">28</span><br></div></div><p>可以看到在<code>initData</code>方法中，最后有比较关键的一行： <code>observe(data, true /* asRootData */)</code>;</p> <p>这个<code>observe</code>方法就是设置数据响应化的地方；</p> <p>找到<code>src/core/observer/index.js</code>;</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>// 外部调用的ovserve方法
export function observe (value: any, asRootData: ?boolean): Observer | void {
  let ob: Observer | void
  ob = new Observer(value)
  return ob
}


export class Observer {
  value: any;
  dep: Dep;
  vmCount: number; // number of vms that have this object as root $data

  constructor (value: any) {
  	.....
    this.value = value
    .....
    if (Array.isArray(value)) {
      if (hasProto) {
        protoAugment(value, arrayMethods)
      } else {
        copyAugment(value, arrayMethods, arrayKeys)
      }
      this.observeArray(value)
    } else {
      this.walk(value)                   // 这里将传入data对象做处理
    }
  }

  /**
   * 给传入对象每个key-value都设置响应getter/setter
   */
  walk (obj: Object) {
    const keys = Object.keys(obj)
    for (let i = 0; i &lt; keys.length; i++) {
      defineReactive(obj, keys[i])                // 主要处理方法
    }
  }
  ......
}
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br><span class="line-number">24</span><br><span class="line-number">25</span><br><span class="line-number">26</span><br><span class="line-number">27</span><br><span class="line-number">28</span><br><span class="line-number">29</span><br><span class="line-number">30</span><br><span class="line-number">31</span><br><span class="line-number">32</span><br><span class="line-number">33</span><br><span class="line-number">34</span><br><span class="line-number">35</span><br><span class="line-number">36</span><br><span class="line-number">37</span><br><span class="line-number">38</span><br><span class="line-number">39</span><br><span class="line-number">40</span><br></div></div><p>一步一步终于能看到做了<code>Object.defineProperty</code>的方法了，那就是<code>denfineReactive</code>这个方法；</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>// src/core/observer/index.js

function defineReactive (obj, key, val) {
	// 这里用到了观察者（发布/订阅）模式进行了劫持封装，它定义了一种一对多的关系，
	// 让多个观察者监听一个主题对象，这个主题对象的状态发生改变时会通知所有观察者对象，观察者对象就可以更新自己的状态。
	const dep = new Dep()
    Object.defineProperty(obj, key, {
        enumerable: true,
        configurable: true,
        get: function reactiveGetter () {
            /* 进行依赖收集 */
            return val;
        },
        set: function reactiveSetter (newVal) {
            if (newVal === val) return;
            dep.notify()                // 触发通知
        }
    });
}
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br></div></div><h2 id="响应式实现"><a href="#响应式实现" class="header-anchor">#</a> 响应式实现</h2> <p>其实响应式系统主要依赖于三部分;</p> <ul><li><p><code>Observe</code> 类</p> <p>主要给响应式对象的属性添加 <code>getter/setter</code> 用于依赖收集与派发更新</p></li> <li><p><code>Dep</code> 类</p> <p>用于收集当前响应式对象的依赖关系</p></li> <li><p><code>Watcher</code> 类</p> <p>观察者，实例分为渲染 watcher、计算属性 watcher、侦听器 watcher 三种</p></li></ul> <p><img src="//img.joyfred.com/vuepress/vue/observe.webp" alt="observe"></p> <h3 id="响应式小结"><a href="#响应式小结" class="header-anchor">#</a> 响应式小结：</h3> <p>watcher 有下面几种使用场景：</p> <ul><li><code>render watcher</code> 渲染 watcher，渲染视图用的 watcher</li> <li><code>computed watcher</code> 计算属性 watcher，因为计算属性即依赖别人也被人依赖，因此也会持有一个 <code>Dep</code> 实例</li> <li><code>watch watcher</code> 侦听器 watcher</li></ul> <p>只要会被别的观察者 (<code>watchers</code>) 依赖，比如 data、data 的属性、计算属性、props，就会在闭包里生成一个 Dep 的实例 <code>dep</code> 并在被调用 <code>getter</code> 的时候 <code>dep.depend</code> 收集它被谁依赖了，并把被依赖的 watcher 存放到自己的 subs 中 <code>this.subs.push(sub)</code>，以便在自身改变的时候通知 <code>notify</code> 存放在 <code>dep.subs</code> 数组中依赖自己的 <code>watchers</code> 自己改变了，请及时 <code>update</code> ~</p> <p>只要依赖别的响应式化对象的对象，都会生成一个观察者 <code>watcher</code> ，用来统计这个 <code>watcher</code> 依赖了哪些响应式对象，在这个 <code>watcher</code> 求值前把当前 <code>watcher</code> 设置到全局 <code>Dep.target</code>，并在自己依赖的响应式对象发生改变的时候及时 <code>update</code></p> <h2 id="异步更新和-nexttick"><a href="#异步更新和-nexttick" class="header-anchor">#</a> 异步更新和 nextTick</h2> <p>引用官网的一段描述，证明 vue 虽然是数据驱动页面，</p> <p>但其在实现上并不是实时的去改变渲染 DOM，而是将改变的数据 DOM 更新加入到队列中，进行一个 tick 的统一渲染处理；</p> <blockquote><p>可能你还没有注意到，Vue 异步执行 DOM 更新。只要观察到数据变化，Vue 将开启一个队列，并缓冲在同一事件循环中发生的所有数据改变。如果同一个 watcher 被多次触发，只会被推入到队列中一次。这种在缓冲时去除重复数据对于避免不必要的计算和 DOM 操作上非常重要。然后，在下一个的事件循环“tick”中，Vue 刷新队列并执行实际 (已去重的) 工作。Vue 在内部尝试对异步队列使用原生的 Promise.then 和 MessageChannel，如果执行环境不支持，会采用 setTimeout(fn, 0) 代替。</p></blockquote> <p>在上面的说过当数据添加响应式 setting 后，数据对象会在改变时调用 setting 函数中的<code>dep.notify()</code>进行通知触发；</p> <p>其本质上是触发了收集依赖器中的每个<code>Wathcer</code>实例的<code>update()</code>方法；</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>// src\core\observer\dep.js

  notify () {
    // stabilize the subscriber list first
    const subs = this.subs.slice()
    if (process.env.NODE_ENV !== 'production' &amp;&amp; !config.async) {
      // subs aren't sorted in scheduler if not running async
      // we need to sort them now to make sure they fire in correct
      // order
      subs.sort((a, b) =&gt; a.id - b.id)
    }
    for (let i = 0, l = subs.length; i &lt; l; i++) {
      subs[i].update()                                  // 触发调用update
    }
  }
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br></div></div><p>而这个被调用的<code>update()</code>方法中，我们可以看到 watcher 实例中进行了判断，</p> <p>如果非<code>lazy</code>或<code>sync</code>模式，那么就会将此<code>watcher</code>实例推入一个观察者队列(queueWatcher)中;</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>// src\core\observer\watcher.js

  update () {
    /* istanbul ignore else */
    if (this.lazy) {
      this.dirty = true
    } else if (this.sync) {
      this.run()
    } else {
      queueWatcher(this)
    }
  }
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br></div></div><p>本质上<code>queueWatcher(this)</code>，就是将当前 watcher 实例进行去重等一系列判断，并加入到观察者队列(queue)中；</p> <p>然后在最后将<code>flushSchedulerQueue()</code>方法，推入<code>nextTick()</code>事件队列中；</p> <p>这里注意，<code>flushSchedulerQueue()</code>方法实际上作用就是执行当前<code>queue</code>队列中的所有<code>watcher</code>实例的<code>run</code>方法，也就是将队列变更都更新至 DOM；</p> <p>看这里并没有直接调用<code>flushSchedulerQueue</code>，而只是将它推入事件队列；</p> <p>这里的事件队列(nextTick)是<strong>微任务（microTask）</strong>，后面细说；</p> <p><strong>所以一个事件队列中，相同的<code>watcher</code>实例只会被推入一次，这也可以得出，在一个事件队列中，一个 watcher 实例就算被多次更改，也只会响应更新最后一次，因为事件 handler 只执行一次；</strong></p> <p>如果 update 调用时想要推入事件，可<code>nextTick</code>事件队列中事件已经执行了（flushing），那就根据 id 排序直接将更新事件放入进行中的队列(queue)；</p> <p>但这里不会重新将事件推入<code>nextTick</code>；</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>// src\core\observer\scheduler.js

export function queueWatcher (watcher: Watcher) {
  const id = watcher.id
  if (has[id] == null) {              // 判断去重
    has[id] = true
    if (!flushing) {
      queue.push(watcher)
    } else {
      // if already flushing, splice the watcher based on its id
      // if already past its id, it will be run next immediately.
      let i = queue.length - 1
      while (i &gt; index &amp;&amp; queue[i].id &gt; watcher.id) {
        i--
      }
      queue.splice(i + 1, 0, watcher)
    }
    // queue the flush
    if (!waiting) {
      waiting = true

      if (process.env.NODE_ENV !== 'production' &amp;&amp; !config.async) {
        flushSchedulerQueue()
        return
      }
      nextTick(flushSchedulerQueue)                // 推入事件队列
    }
  }
}
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br><span class="line-number">24</span><br><span class="line-number">25</span><br><span class="line-number">26</span><br><span class="line-number">27</span><br><span class="line-number">28</span><br><span class="line-number">29</span><br></div></div><h2 id="nexttick"><a href="#nexttick" class="header-anchor">#</a> nextTick</h2> <p>在 nextTick 中发生了什么呢？</p> <p>源码中可以得知，这个方法是将传入的事件都放入了定义的<code>callbacks</code>这个数组中， 这个数组就被定义为<code>eventLoop</code>；</p> <p>一个事件循环；</p> <p>然后在一个事件循环开始后，使用<code>microTask</code>的方式（2.6 中优先使用 promise）执行所有<code>callbacks</code>数组中的队列事件；</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>// src\core\util\next-tick.js

export function nextTick (cb?: Function, ctx?: Object) {       // 这个就是调用的方法 包括$nextTick
  let _resolve
  callbacks.push(() =&gt; {             // 将传入事件再放入一个匿名函数中，推入事件队列callbacks
    if (cb) {
      try {
        cb.call(ctx)
      } catch (e) {
        handleError(e, ctx, 'nextTick')
      }
    } else if (_resolve) {
      _resolve(ctx)
    }
  })
  if (!pending) {
    pending = true       // 开启异步锁
    timerFunc()         // 执行事件队列  这个方法会根据执行环境（兼容性）选择相应的microTask方法
  }
  // $flow-disable-line
  if (!cb &amp;&amp; typeof Promise !== 'undefined') {
    return new Promise(resolve =&gt; {
      _resolve = resolve
    })
  }
}


// 例如使用promise
if (typeof Promise !== 'undefined' &amp;&amp; isNative(Promise)) {
  const p = Promise.resolve()
  timerFunc = () =&gt; {        // 这里就给浏览器中插入一个异步事件（等待同步事件执行后 开始执行）
    p.then(flushCallbacks)                // 通过promise执行 flushCallbacks函数 也就是开始事件队列
    if (isIOS) setTimeout(noop)
  }
  isUsingMicroTask = true
}

// 这里是开始执行队列的方法
function flushCallbacks () {
  pending = false
  const copies = callbacks.slice(0)
  callbacks.length = 0
  for (let i = 0; i &lt; copies.length; i++) {        // 执行队列中所有事件
    copies[i]()
  }
}
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br><span class="line-number">24</span><br><span class="line-number">25</span><br><span class="line-number">26</span><br><span class="line-number">27</span><br><span class="line-number">28</span><br><span class="line-number">29</span><br><span class="line-number">30</span><br><span class="line-number">31</span><br><span class="line-number">32</span><br><span class="line-number">33</span><br><span class="line-number">34</span><br><span class="line-number">35</span><br><span class="line-number">36</span><br><span class="line-number">37</span><br><span class="line-number">38</span><br><span class="line-number">39</span><br><span class="line-number">40</span><br><span class="line-number">41</span><br><span class="line-number">42</span><br><span class="line-number">43</span><br><span class="line-number">44</span><br><span class="line-number">45</span><br><span class="line-number">46</span><br><span class="line-number">47</span><br></div></div><p>这里很有趣的一点，就是异步锁<code>pending</code>这个概念；</p> <p>起初看到这里，不太明白为什么为什么要加一个<code>pending</code>，然后看到一篇文章讲到这部分举了一个例子：</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>这里的Pending打个比喻：
相当于一群旅客准备上车，当第一个旅客上车的时候，车开始发动，准备出发，等到所有旅客都上车后，就可以正式开车了。
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br></div></div><p>啊，有点意思了。解释一下，<strong>第一个旅客上车，车开始发动</strong>也就相当于刚进入<code>nextTick()</code>事件时，将<code>pending</code>设为 true，并执行<code>timerFunc</code>方法；</p> <p>执行<code>timerFunc</code>就相当于发动了车，因为<code>timerFunc</code>在实现中是一个<code>promise</code>函数，也就是一个<code>microTask</code>，执行后就给浏览器插入了一个异步任务；</p> <p><strong>等到所有旅客都上车后</strong>，这个比喻可以理解为，当异步锁开启后，虽然不再调用<code>timerFunc</code>插入异步任务了，但此时调用<code>nextTick</code>仍可以继续向<code>callbacks</code>事件队列中插入事件；</p> <p>这时插入的事件，就是发动车时后续上的旅客；</p> <p>然后当浏览器同步代码任务执行完后，开始执行了异步任务了，也就是我们的<code>timerFunc</code>了，内部就调用了我们的<code>flushCallbacks</code>，这个函数第一句就是将异步锁关闭，也就是开车了！</p> <p>正式执行这整个事件循环，同时清空之前的事件队列，也就是之后的事件就加入下一个事件队列；</p> <p>从比喻上来说，可以形象理解成这班车开车了！你再用<code>nextTick</code>加进来的旅客，那就等下一班车吧！</p> <p>经过这个例子，顿觉醍醐灌顶！也不由得佩服尤大在异步更新上这方面的思维想法！</p> <h3 id="vue-中的微任务"><a href="#vue-中的微任务" class="header-anchor">#</a> vue 中的微任务</h3> <p>vue 中<code>nextTick</code>的实现也经过了多次调整，比如 2.5 和 2.6 就进行了调整；</p> <blockquote><ul><li>2.6 版本优先使用 microtask 作为异步延迟包装器，且写法相对简单。</li> <li>2.5 版本中，nextTick 的实现是 microTimerFunc、macroTimerFunc 组合实现的，延迟调用优先级是：Promise &gt; setImmediate &gt; MessageChannel &gt; setTimeout，具体见源码。</li></ul></blockquote></div> <footer class="page-edit"><!----> <!----></footer> <div class="page-nav"><p class="inner"><span class="prev">
      ←
      <a href="/vbook/front-end/vue/vue知识点.html" class="prev">
        vue知识点
      </a></span> <span class="next"><a href="/vbook/front-end/vue/vue源码-总结.html">
        vue源码-总结
      </a>
      →
    </span></p></div> </main></div><div class="global-ui"></div></div>
    <script src="/vbook/assets/js/app.64803a45.js" defer></script><script src="/vbook/assets/js/2.dceffa7a.js" defer></script><script src="/vbook/assets/js/43.fdc58166.js" defer></script>
  </body>
</html>
