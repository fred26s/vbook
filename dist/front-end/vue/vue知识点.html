<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>MVVM 理解 | BLOG</title>
    <meta name="generator" content="VuePress 1.5.4">
    <link rel="icon" href="/vbook/favicon.ico">
    <meta name="description" content="学习笔记">
    <link rel="preload" href="/vbook/assets/css/0.styles.e0606203.css" as="style"><link rel="preload" href="/vbook/assets/js/app.3b385a05.js" as="script"><link rel="preload" href="/vbook/assets/js/2.2ce5df5b.js" as="script"><link rel="preload" href="/vbook/assets/js/42.dd0380bd.js" as="script"><link rel="prefetch" href="/vbook/assets/js/10.6f2d8bc8.js"><link rel="prefetch" href="/vbook/assets/js/11.c69ee5aa.js"><link rel="prefetch" href="/vbook/assets/js/12.e204f4f1.js"><link rel="prefetch" href="/vbook/assets/js/13.1883e67e.js"><link rel="prefetch" href="/vbook/assets/js/14.755d7778.js"><link rel="prefetch" href="/vbook/assets/js/15.7e722045.js"><link rel="prefetch" href="/vbook/assets/js/16.8a84fe06.js"><link rel="prefetch" href="/vbook/assets/js/17.d851d255.js"><link rel="prefetch" href="/vbook/assets/js/18.10bf8f28.js"><link rel="prefetch" href="/vbook/assets/js/19.b4d18bac.js"><link rel="prefetch" href="/vbook/assets/js/20.e82790c5.js"><link rel="prefetch" href="/vbook/assets/js/21.ef1a1af6.js"><link rel="prefetch" href="/vbook/assets/js/22.c1aad3a2.js"><link rel="prefetch" href="/vbook/assets/js/23.f403526b.js"><link rel="prefetch" href="/vbook/assets/js/24.447556ba.js"><link rel="prefetch" href="/vbook/assets/js/25.8f1830d8.js"><link rel="prefetch" href="/vbook/assets/js/26.1aee2451.js"><link rel="prefetch" href="/vbook/assets/js/27.a86b3044.js"><link rel="prefetch" href="/vbook/assets/js/28.508d01f9.js"><link rel="prefetch" href="/vbook/assets/js/29.dbe0222b.js"><link rel="prefetch" href="/vbook/assets/js/3.dfccb20d.js"><link rel="prefetch" href="/vbook/assets/js/30.29ae2259.js"><link rel="prefetch" href="/vbook/assets/js/31.ece9409c.js"><link rel="prefetch" href="/vbook/assets/js/32.455c0172.js"><link rel="prefetch" href="/vbook/assets/js/33.d78a6fd6.js"><link rel="prefetch" href="/vbook/assets/js/34.dbb055b1.js"><link rel="prefetch" href="/vbook/assets/js/35.158a349a.js"><link rel="prefetch" href="/vbook/assets/js/36.5791d7c4.js"><link rel="prefetch" href="/vbook/assets/js/37.ef1f5814.js"><link rel="prefetch" href="/vbook/assets/js/38.d69658c1.js"><link rel="prefetch" href="/vbook/assets/js/39.601fbcdd.js"><link rel="prefetch" href="/vbook/assets/js/4.d599a372.js"><link rel="prefetch" href="/vbook/assets/js/40.f6913db6.js"><link rel="prefetch" href="/vbook/assets/js/41.99ac89f4.js"><link rel="prefetch" href="/vbook/assets/js/43.d033d384.js"><link rel="prefetch" href="/vbook/assets/js/44.0bf3fc34.js"><link rel="prefetch" href="/vbook/assets/js/45.fc46fe1d.js"><link rel="prefetch" href="/vbook/assets/js/46.b812e66f.js"><link rel="prefetch" href="/vbook/assets/js/5.525c50d0.js"><link rel="prefetch" href="/vbook/assets/js/6.f6b821c1.js"><link rel="prefetch" href="/vbook/assets/js/7.61ee7893.js"><link rel="prefetch" href="/vbook/assets/js/8.b54700d3.js"><link rel="prefetch" href="/vbook/assets/js/9.a6110085.js">
    <link rel="stylesheet" href="/vbook/assets/css/0.styles.e0606203.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div class="theme-container"><header class="navbar"><div class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div> <a href="/vbook/" class="home-link router-link-active"><!----> <span class="site-name">BLOG</span></a> <div class="links"><div class="search-box"><input aria-label="Search" autocomplete="off" spellcheck="false" value=""> <!----></div> <nav class="nav-links can-hide"><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="前端学习笔记" class="dropdown-title"><span class="title">前端学习笔记</span> <span class="arrow down"></span></button> <button type="button" aria-label="前端学习笔记" class="mobile-dropdown-title"><span class="title">前端学习笔记</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/vbook/front-end/evo/优化方式.html" class="nav-link">
  前端优化
</a></li><li class="dropdown-item"><!----> <a href="/vbook/front-end/js/es6知识.html" class="nav-link">
  JS
</a></li><li class="dropdown-item"><!----> <a href="/vbook/front-end/vue/vue知识点.html" class="nav-link">
  VUE
</a></li><li class="dropdown-item"><!----> <a href="/vbook/front-end/webpack/webpack基础.html" class="nav-link">
  Webpack
</a></li><li class="dropdown-item"><!----> <a href="/vbook/front-end/net/网络基础.html" class="nav-link">
  网络基础
</a></li><li class="dropdown-item"><!----> <a href="/vbook/front-end/tools/GIT.html" class="nav-link">
  开发工具
</a></li><li class="dropdown-item"><!----> <a href="/vbook/front-end/ci/travis自动部署.html" class="nav-link">
  前端自动化
</a></li></ul></div></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="后台学习笔记" class="dropdown-title"><span class="title">后台学习笔记</span> <span class="arrow down"></span></button> <button type="button" aria-label="后台学习笔记" class="mobile-dropdown-title"><span class="title">后台学习笔记</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/vbook/back-end/node/express.html" class="nav-link">
  NodeJS
</a></li><li class="dropdown-item"><!----> <a href="/vbook/back-end/lib-web/RESTful.html" class="nav-link">
  web开发知识
</a></li><li class="dropdown-item"><!----> <a href="/vbook/back-end/server/Nginx.html" class="nav-link">
  服务器
</a></li></ul></div></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="JustDoIT" class="dropdown-title"><span class="title">JustDoIT</span> <span class="arrow down"></span></button> <button type="button" aria-label="JustDoIT" class="mobile-dropdown-title"><span class="title">JustDoIT</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/vbook/funs/hardware/arduino.html" class="nav-link">
  硬件
</a></li></ul></div></div> <!----></nav></div></header> <div class="sidebar-mask"></div> <aside class="sidebar"><nav class="nav-links"><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="前端学习笔记" class="dropdown-title"><span class="title">前端学习笔记</span> <span class="arrow down"></span></button> <button type="button" aria-label="前端学习笔记" class="mobile-dropdown-title"><span class="title">前端学习笔记</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/vbook/front-end/evo/优化方式.html" class="nav-link">
  前端优化
</a></li><li class="dropdown-item"><!----> <a href="/vbook/front-end/js/es6知识.html" class="nav-link">
  JS
</a></li><li class="dropdown-item"><!----> <a href="/vbook/front-end/vue/vue知识点.html" class="nav-link">
  VUE
</a></li><li class="dropdown-item"><!----> <a href="/vbook/front-end/webpack/webpack基础.html" class="nav-link">
  Webpack
</a></li><li class="dropdown-item"><!----> <a href="/vbook/front-end/net/网络基础.html" class="nav-link">
  网络基础
</a></li><li class="dropdown-item"><!----> <a href="/vbook/front-end/tools/GIT.html" class="nav-link">
  开发工具
</a></li><li class="dropdown-item"><!----> <a href="/vbook/front-end/ci/travis自动部署.html" class="nav-link">
  前端自动化
</a></li></ul></div></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="后台学习笔记" class="dropdown-title"><span class="title">后台学习笔记</span> <span class="arrow down"></span></button> <button type="button" aria-label="后台学习笔记" class="mobile-dropdown-title"><span class="title">后台学习笔记</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/vbook/back-end/node/express.html" class="nav-link">
  NodeJS
</a></li><li class="dropdown-item"><!----> <a href="/vbook/back-end/lib-web/RESTful.html" class="nav-link">
  web开发知识
</a></li><li class="dropdown-item"><!----> <a href="/vbook/back-end/server/Nginx.html" class="nav-link">
  服务器
</a></li></ul></div></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="JustDoIT" class="dropdown-title"><span class="title">JustDoIT</span> <span class="arrow down"></span></button> <button type="button" aria-label="JustDoIT" class="mobile-dropdown-title"><span class="title">JustDoIT</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/vbook/funs/hardware/arduino.html" class="nav-link">
  硬件
</a></li></ul></div></div> <!----></nav>  <ul class="sidebar-links"><li><section class="sidebar-group depth-0"><p class="sidebar-heading open"><span>Vue2.x</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/vbook/front-end/vue/vue知识点.html" class="active sidebar-link">vue知识点</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/vbook/front-end/vue/vue知识点.html#mvvm-理解" class="sidebar-link">MVVM 理解</a></li><li class="sidebar-sub-header"><a href="/vbook/front-end/vue/vue知识点.html#vue-生命周期" class="sidebar-link">Vue 生命周期</a></li><li class="sidebar-sub-header"><a href="/vbook/front-end/vue/vue知识点.html#vue-组件通信" class="sidebar-link">Vue 组件通信</a></li><li class="sidebar-sub-header"><a href="/vbook/front-end/vue/vue知识点.html#vuex-状态管理" class="sidebar-link">VueX 状态管理</a></li><li class="sidebar-sub-header"><a href="/vbook/front-end/vue/vue知识点.html#vue-双向数据绑定" class="sidebar-link">Vue 双向数据绑定</a></li><li class="sidebar-sub-header"><a href="/vbook/front-end/vue/vue知识点.html#vue2-x-和-vue3-区别" class="sidebar-link">Vue2.x 和 vue3 区别</a></li><li class="sidebar-sub-header"><a href="/vbook/front-end/vue/vue知识点.html#为什么需要-dom-diff" class="sidebar-link">为什么需要 DOM diff</a></li><li class="sidebar-sub-header"><a href="/vbook/front-end/vue/vue知识点.html#virtual-dom" class="sidebar-link">Virtual DOM</a></li><li class="sidebar-sub-header"><a href="/vbook/front-end/vue/vue知识点.html#diff-逻辑" class="sidebar-link">diff 逻辑</a></li><li class="sidebar-sub-header"><a href="/vbook/front-end/vue/vue知识点.html#异步更新" class="sidebar-link">异步更新</a></li><li class="sidebar-sub-header"><a href="/vbook/front-end/vue/vue知识点.html#typescript" class="sidebar-link">typescript</a></li><li class="sidebar-sub-header"><a href="/vbook/front-end/vue/vue知识点.html#d-ts" class="sidebar-link">d.ts</a></li></ul></li><li><a href="/vbook/front-end/vue/vue源码-解读.html" class="sidebar-link">vue源码-解读</a></li><li><a href="/vbook/front-end/vue/vue源码-总结.html" class="sidebar-link">vue源码-总结</a></li></ul></section></li></ul> </aside> <main class="page"> <div class="theme-default-content content__default"><h2 id="mvvm-理解"><a href="#mvvm-理解" class="header-anchor">#</a> MVVM 理解</h2> <p>首先 MVVM 是一种架构模式；</p> <p>Vue、react 作为其模式的一种代表实现广为流行；</p> <p>MVVM 区别于 MVC，model 数据层和 view 视图层的直接关联；</p> <p>在 M 与 V 之间加入了 VM(ViewModel )层，也可以理解将 view 层，拆分为了 MVVM；</p> <p>实际 VM 就是链接 V 和 M 的桥梁，之前的模式我们获取数据 model 后，需要手动渲染 DOM 页面；</p> <p>而 MVVM 模式下，</p> <p>但是有 VM 这个中间件，实现了数据驱动页面的模式，因为视图状态和事件行为都封装在了 vm 中；</p> <p>由于实现了数据的双向绑定，所以开发者不用再去关注如果通过数据改变页面，而是只关心数据在 VM 中的改变即可。</p> <p><strong>MVVM 模式：不需要用户手动的操作 dom 的，主要是实现数据双向绑定</strong></p> <ul><li><h3 id="优点"><a href="#优点" class="header-anchor">#</a> 优点:</h3> <ol><li>分离视图（View）和模型（Model）,降低代码耦合，提高视图或者逻辑的重用性: 比如视图（View）可以独立于 Model 变化和修改，一个 ViewModel 可以绑定不同的&quot;View&quot;上，当 View 变化的时候 Model 不可以不变，当 Model 变化的时候 View 也可以不变。你可以把一些视图逻辑放在一个 ViewModel 里面，让很多 view 重用这段视图逻辑</li> <li>自动更新 dom: 利用双向绑定,数据更新后视图自动更新,让开发者从繁琐的手动 dom 中解放</li></ol></li> <li><h3 id="缺点"><a href="#缺点" class="header-anchor">#</a> 缺点</h3> <ol><li><p>Bug 很难被调试:</p> <p>因为使用双向绑定的模式，当你看到界面异常了，有可能是你 View 的代码有 Bug，也可能是 Model 的代码有问题。</p> <p>数据绑定使得一个位置的 Bug 被快速传递到别的位置，要定位原始出问题的地方就变得不那么容易了。</p> <p>需要使用调试工具： vue-devtool</p></li></ol></li></ul> <h2 id="vue-生命周期"><a href="#vue-生命周期" class="header-anchor">#</a> Vue 生命周期</h2> <p>生命周期就是 Vue 实例从创建到销毁的这个过程。</p> <p>Vue 实例有一个完整的生命周期，也可以分为三个阶段：</p> <ul><li><strong>初始化阶段</strong>：开始创建、初始化数据、编译模版、挂载 Dom -&gt; created \ mounted</li> <li><strong>运行阶段</strong>：渲染、更新 -&gt; update</li> <li><strong>销毁阶段</strong>：渲染、卸载 -&gt; destoryed</li></ul> <p>等一系列过程，我们称这是 Vue 的生命周期。</p> <p>钩子函数</p> <ul><li><p>beforeCreate：创建前，此阶段为实例初始化之后，this 指向创建的实例，此时的数据观察事件机制都未形成，不能获得 DOM 节点</p> <p>常用：可以在这加个 loading 事件。</p></li> <li><p>created：创建后，此阶段为实例已经创建，完成数据（data、props、computed）的初始化导入依赖项。</p> <p>常用：可以在这里结束 loading 事件，还做一些初始化，实现函数自执行。</p></li> <li><p>beforeMount：挂载前，虽然得不到具体的 DOM 元素，但 vue 挂载的根节点已经创建，下面 vue 对 DOM 的操作将围绕这个根元素继续进行。</p> <p>常用：不常用</p></li> <li><p>mounted：挂载，完成创建 vm.$el，和双向绑定</p> <p>常用：可在这发起后端请求，拿回数据，配合路由钩子做一些事情。</p></li> <li><p>beforeUpdate：数据更新前，数据驱动 DOM。</p> <p>常用：不常用可在更新前访问现有的 DOM，如手动移出添加的事件监听器。</p></li> <li><p>beforeDestroy：销毁前，</p> <p>可做一些删除提示，如：您确定删除 xx 吗？ 取消一些手动添加的事件</p></li></ul> <p><img src="//img.joyfred.com/vuepress/vue/%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F.png" alt="生命周期"></p> <h2 id="vue-组件通信"><a href="#vue-组件通信" class="header-anchor">#</a> Vue 组件通信</h2> <p>Vue 组件通信的方法如下:</p> <ul><li><p>props/$emit+v-on:</p> <p>通过 props 将数据自上而下传递，而通过$emit 和 v-on 来向上传递信息。</p> <p>符合单项数据流原则。</p></li> <li><p>EventBus:</p> <p>通过 EventBus 事件总线进行信息的发布与订阅 （<strong>不推荐</strong>，易逻辑混乱）</p></li> <li><p>vuex:</p> <p>是全局数据管理库，可以通过 vuex 管理全局的数据流 （可完全代替 EventBus）</p></li> <li><p>$attrs/$listeners:</p> <p>Vue2.4 中加入的$attrs/$listeners 可以进行跨级的组件通信</p></li> <li><p>provide/inject：</p> <p>以允许一个祖先组件向其所有子孙后代注入一个依赖，不论组件层次有多深，并在起上下游关系成立的时间里始终生效，这成为了跨组件通信的基础</p></li></ul> <p>事件通讯对比</p> <ul><li>vuex 是官方推出的，事件总线是高手在民间</li> <li>在大型应用方面，vuex 确实是一个比 EventBus 更好的解决方案</li> <li>vuex 更加易于调试与管理</li> <li>Vuex 并不是最佳的解决方案，在某些小型应用上，你可能只有小部分的数据交互，甚至只有一个登录状态储存，那样事件总线或者<a href="https://cn.vuejs.org/v2/guide/state-management.html#%E7%AE%80%E5%8D%95%E7%8A%B6%E6%80%81%E7%AE%A1%E7%90%86%E8%B5%B7%E6%AD%A5%E4%BD%BF%E7%94%A8" target="_blank" rel="noopener noreferrer">简单状态管理<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>都是值得推荐的。</li></ul> <p>毕竟 vue 是一个渐进式框架，选择什么工具和解决方案，还是根据项目具体情况来决定。</p> <h2 id="vuex-状态管理"><a href="#vuex-状态管理" class="header-anchor">#</a> VueX 状态管理</h2> <ul><li><h3 id="概念"><a href="#概念" class="header-anchor">#</a> 概念：</h3> <p>Vuex 是一个专为 Vue.js 应用程序开发的状态管理插件；</p> <p>核心就是 store（仓库），store 中存放着组件间需要动态共享的数据状态；</p></li> <li><h3 id="优势"><a href="#优势" class="header-anchor">#</a> 优势：</h3> <p>因为组件间通信存在着一定问题，例如兄弟组件和祖辈组件之间数据传递复杂，所以 Vuex 可以方便的解决这个问题；</p> <p>同时也解决了<code>eventBus</code>在大型项目中，会造成事件复杂耦合难以理解的问题。</p></li> <li><h3 id="举例"><a href="#举例" class="header-anchor">#</a> 举例：</h3> <p>例如两个兄弟组件同时依赖一个共同数据，那么这个数据如何传递？</p> <p>例如不依赖其他手段，可能我们需要他们的共同父组件来管理这个共同依赖的数据，非常麻烦；</p> <p>如果用 vuex，我们就可以将这个共用的数据存在 store 中，并且其中一个组件如果想要改变值，</p> <p>那么可以调用 store 中统一的修改方法<code>mutation</code>，其他依赖这个 store 数据组件也可以动态的获取最新改变后的值;</p></li> <li><h3 id="使用"><a href="#使用" class="header-anchor">#</a> 使用：</h3> <p>State：</p> <p>​ 单一状态树。</p> <p>Getter：</p> <p>​ 计算属性。</p> <p>Mutation：</p> <p>​ 用于提交更改 store 中的状态（mutation 是更改 store 中状态的唯一方法）。</p> <p>​ mutation 必须是同步操作；</p> <p>​ 因为例如，当你能调用了两个包含异步回调的 mutation 来改变状态，你怎么知道什么时候回调和哪个先回调呢</p> <p>Action：</p> <p>​ 用于提交 mutation，可以包含异步操作。</p> <p>Module：</p> <p>​ 当应用程序很大时，需要管理的状态很多时，需要将 state 进行拆分，分割成模块（modules)，最后统一管理。</p> <p>​ 命名空间：namespaced: true, 为什么要加这个呢？默认情况下，模块内部的 action、mutation 和 getter 是注册在**「全局命名空间」**的。</p> <p>​ 因为有可能在不同模块下定义了相同的方法就会产生覆盖，所以通过添加 namespace 进行区分。</p></li></ul> <h2 id="vue-双向数据绑定"><a href="#vue-双向数据绑定" class="header-anchor">#</a> Vue 双向数据绑定</h2> <p>​ vue 实际上利用了原生的<code>Object.definedProperty()</code>，在 new vue 实例时对他所有响应式化的数据对象进行递归遍历，对每一个依赖收集的属性添加<code>setter/getter</code>来实现数据劫持；</p> <p>​ 这样在获取这个数据时，触发<code>getter</code>就会将当前<code>watcher</code>实例加入这个对象属性的被依赖列表中，那么当这个数据再次改变时，就会触发<code>setter</code>，通知依赖自己的<code>watcher</code>实例进行<code>update</code>更新视图。</p> <p>​ 这就完成了单向的数据绑定，数据改变相应的视图更新；</p> <p>​ 而双向数据绑定，相当于给视图 UI 增加了<code>input</code>事件来实时修改<code>data</code>数据，例如<code>v-model</code>语法糖；</p> <ul><li><h3 id="依赖收集"><a href="#依赖收集" class="header-anchor">#</a> 依赖收集</h3> <p>依赖收集其实发生在 vue 实例的初始化阶段，当初始化数据后，就会遍历挂载的对象属性，进行响应式化处理；</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>依赖收集主要围绕三个概念类，Observe、Dep、Watcher;
- Observe类
首先通过`defineReactive`给每个对象属性增加响应式化（实现为definePorperty）;
给每个对象属性递归添加getter/setter；
所以当取值/改值时，触发getter/setter中的Dep依赖收集和派发更新；
- Dep类
dep作为依赖搜集器，用来收集Watcher的实例，用来通知更新；
- Watcher类
new实例时（初始化/mount时），添加Dep.target Watcher;
获取getter时，通过dep.depend添加依赖，
这里是Dep和Watcher方法间互相调用的过程，Dep中使用保存的`target watcher`去调用`addDep`方法；
watcher中的`addDep`方法又用传入的dep实例，调用`addSub`方法来将自身添加到dep依赖中；
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br></div></div></li> <li><h3 id="响应式系统简述"><a href="#响应式系统简述" class="header-anchor">#</a> 响应式系统简述:</h3> <ul><li>任何一个 Vue Component 都有一个与之对应的 Watcher 实例。</li> <li>Vue 的 data 上的属性会被添加 getter 和 setter 属性。</li> <li>当 Vue Component render 函数被执行的时候, data 上会被 触碰(touch), 即被读, getter 方法会被调用, 此时 Vue 会去记录此 Vue component 所依赖的所有 data。(这一过程被称为依赖收集)</li> <li>data 被改动时（主要是用户操作）, 即被写, setter 方法会被调用, 此时 Vue 会去通知所有依赖于此 data 的组件去调用他们的 render 函数进行更新。</li></ul></li></ul> <h2 id="vue2-x-和-vue3-区别"><a href="#vue2-x-和-vue3-区别" class="header-anchor">#</a> Vue2.x 和 vue3 区别</h2> <ul><li><h3 id="proxy-与-object-defineproperty"><a href="#proxy-与-object-defineproperty" class="header-anchor">#</a> Proxy 与 Object.defineProperty</h3> <p>vue 在 3 中将实现响应式的方法由 Object.defineProperty 改为了<code>proxy</code>；</p> <p><strong>Proxy 的优势如下:</strong></p> <ul><li>Proxy 可以直接监听对象而非属性</li> <li>Proxy 可以直接监听数组的变化</li> <li>Proxy 有多达 13 种拦截方法,不限于 apply、ownKeys、deleteProperty、has 等等是<code>Object.defineProperty</code>不具备的</li> <li>Proxy 返回的是一个新对象,我们可以只操作新的对象达到目的,而<code>Object.defineProperty</code>只能遍历对象属性直接修改</li> <li>Proxy 作为新标准将受到浏览器厂商重点持续的性能优化，也就是传说中的新标准的性能红利</li></ul> <p><strong>Object.defineProperty 的优势如下:</strong></p> <ul><li>兼容性好,支持 IE9</li></ul></li> <li><h3 id="组合式-api"><a href="#组合式-api" class="header-anchor">#</a> 组合式 API</h3></li></ul> <h2 id="为什么需要-dom-diff"><a href="#为什么需要-dom-diff" class="header-anchor">#</a> 为什么需要 DOM diff</h2> <p>因为 vue2.0 属于中等粒度的更新，组件的每个数据只是与组件建立依赖关系，内存开销变少了，这也是 vdom 的 diff 更新机制给 vue 带来的能力</p> <p>所以根据目前的响应式系统，通常我们会第一时间侦测到发生变化的组件，然后在组件内部进行 Virtual Dom Diff 获取更加具体的差异,而 Virtual Dom Diff 则是 pull 操作,Vue 是 push+pull 结合的方·式进行变化侦测的.</p> <h2 id="virtual-dom"><a href="#virtual-dom" class="header-anchor">#</a> Virtual DOM</h2> <ul><li><h3 id="概念-2"><a href="#概念-2" class="header-anchor">#</a> 概念</h3> <p>Virtual DOM 是对 DOM 的抽象,本质上是 JavaScript 对象,这个对象就是更加轻量级的对 DOM 的描述；</p></li> <li><h3 id="存在价值"><a href="#存在价值" class="header-anchor">#</a> 存在价值</h3> <ul><li><p>提升性能</p> <p>因为频繁变动 DOM 会造成浏览器的回流或者重回,这些都是性能的杀手,因此我们通过使用 VirtualDOM,</p> <p>在 patch 过程中尽可能地一次性将差异更新到 DOM 中;并且无需手动操作 DOM；</p></li> <li><p>跨平台</p> <p>例如实现 SSR，因为服务端 nodejs 就没有 DOM，所以使用 virtualDOM 可以解决跨平台问题。</p></li></ul></li></ul> <h2 id="diff-逻辑"><a href="#diff-逻辑" class="header-anchor">#</a> diff 逻辑</h2> <p>diff 的目的就是比较新旧 Virtual DOM Tree 找出差异并更新.</p> <ul><li>头头对比: 对比两个数组的头部，如果找到，把新节点 patch 到旧节点，头指针后移</li> <li>尾尾对比: 对比两个数组的尾部，如果找到，把新节点 patch 到旧节点，尾指针前移</li> <li>旧尾新头对比: 交叉对比，旧尾新头，如果找到，把新节点 patch 到旧节点，旧尾指针前移，新头指针后移</li> <li>旧头新尾对比: 交叉对比，旧头新尾，如果找到，把新节点 patch 到旧节点，新尾指针前移，旧头指针后移</li> <li>利用 key 对比: 用新指针对应节点的 key 去旧数组寻找对应的节点,这里分三种情况,当没有对应的 key，那么创建新的节点,如果有 key 并且是相同的节点，把新节点 patch 到旧节点,如果有 key 但是不是相同的节点，则创建新节点</li></ul> <h2 id="异步更新"><a href="#异步更新" class="header-anchor">#</a> 异步更新</h2> <h2 id="typescript"><a href="#typescript" class="header-anchor">#</a> typescript</h2> <ul><li><p>好处</p> <ul><li><p>IDAE 提示丰富</p> <p><strong>为什么 IDEA 可以支持 TS 类型系统</strong></p></li> <li><p>增加类型系统</p></li> <li><p>便于后期维护</p></li></ul></li> <li><p>缺点</p> <ul><li>前期需要增加大量工作</li></ul></li> <li><h2 id="d-ts"><a href="#d-ts" class="header-anchor">#</a> d.ts</h2></li></ul></div> <footer class="page-edit"><!----> <!----></footer> <div class="page-nav"><p class="inner"><!----> <span class="next"><a href="/vbook/front-end/vue/vue源码-解读.html">
        vue源码-解读
      </a>
      →
    </span></p></div> </main></div><div class="global-ui"></div></div>
    <script src="/vbook/assets/js/app.3b385a05.js" defer></script><script src="/vbook/assets/js/2.2ce5df5b.js" defer></script><script src="/vbook/assets/js/42.dd0380bd.js" defer></script>
  </body>
</html>
