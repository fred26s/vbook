(window.webpackJsonp=window.webpackJsonp||[]).push([[34],{378:function(_,v,a){"use strict";a.r(v);var e=a(42),t=Object(e.a)({},(function(){var _=this,v=_.$createElement,a=_._self._c||v;return a("ContentSlotsDistributor",{attrs:{"slot-key":_.$parent.slotKey}},[a("h2",{attrs:{id:"浏览器缓存策略"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#浏览器缓存策略"}},[_._v("#")]),_._v(" 浏览器缓存策略")]),_._v(" "),a("p",[_._v("一张图介绍浏览器在处理缓存策略时的步骤")]),_._v(" "),a("p",[a("img",{attrs:{src:"//img.joyfred.com/vuepress/evo/brw-cache.jpg",alt:"img"}})]),_._v(" "),a("p",[_._v("分析一下图中几个关键分支点：")]),_._v(" "),a("h2",{attrs:{id:"_1-判断是否存在缓存"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_1-判断是否存在缓存"}},[_._v("#")]),_._v(" 1.判断是否存在缓存")]),_._v(" "),a("p",[_._v("浏览器如何判断当前资源是否存在缓存呢？")]),_._v(" "),a("p",[_._v("这里可分为 "),a("strong",[_._v("强制缓存")]),_._v(" 和 "),a("strong",[_._v("协商缓存")]),_._v("；")]),_._v(" "),a("p",[a("strong",[_._v("强制缓存")])]),_._v(" "),a("p",[_._v("即通过服务器响应头中的 "),a("code",[_._v("expires和cache-control")]),_._v("来判断；（这两个标头后面详解）")]),_._v(" "),a("p",[_._v("如果还在强制缓存的有效期内，直接获取缓存数据资源；")]),_._v(" "),a("p",[a("strong",[_._v("协商缓存")])]),_._v(" "),a("p",[_._v("如果强制缓存失效，那么即进入协商缓存，")]),_._v(" "),a("p",[_._v("浏览器会在请求头上带上标头"),a("code",[_._v("Etag / If-None-Match")]),_._v("和"),a("code",[_._v("Last-Modified / If-Modified-Since")]),_._v(";")]),_._v(" "),a("p",[_._v("服务端通过这两组标头进行判断资源是否发生改变，决定返回 304/200；")]),_._v(" "),a("h2",{attrs:{id:"_2-判断缓存是否过期"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_2-判断缓存是否过期"}},[_._v("#")]),_._v(" 2.判断缓存是否过期")]),_._v(" "),a("p",[_._v("通过首次请求资源时，服务端响应头中的"),a("code",[_._v("expires和cache-control")]),_._v(",表示了缓存有效期；")]),_._v(" "),a("p",[a("strong",[_._v("expires")])]),_._v(" "),a("p",[_._v("Expires 是 HTTP/1.0 控制网页缓存的字段，其值为服务器返回该请求结果缓存的到期准确时间，")]),_._v(" "),a("p",[_._v("例如"),a("code",[_._v("expires: Sat, 06 Jun 2020 09:24:34 GMT")])]),_._v(" "),a("p",[_._v("即再次发起该请求时，如果客户端的时间小于 Expires 的值时，直接使用缓存结果。")]),_._v(" "),a("p",[a("strong",[_._v("cache-control")])]),_._v(" "),a("p",[_._v("cache-control 是 HTTP/1.1 控制网页缓存的字段， 其值为一个数字相对值，以秒为单位；")]),_._v(" "),a("p",[_._v("例如 "),a("code",[_._v("Cache-Control: max-age=300")])]),_._v(" "),a("p",[_._v("即在此发起该请求时，如果在 Date+maxage 时间长度内，直接使用缓存结果；")]),_._v(" "),a("blockquote",[a("p",[_._v("注：在无法确定客户端的时间是否与服务端的时间同步的情况下，Cache-Control 相比于 expires 是更好的选择，所以同时存在时，只有 Cache-Control 生效。")])]),_._v(" "),a("h2",{attrs:{id:"_3-判断-etag"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_3-判断-etag"}},[_._v("#")]),_._v(" 3.判断 ETag")]),_._v(" "),a("p",[_._v("当判断缓存过期后，即进入了协商缓存阶段；")]),_._v(" "),a("p",[_._v("上面说了协商缓存阶段，会根据请求头中的两组标头来判断；")]),_._v(" "),a("p",[_._v("分别是")]),_._v(" "),a("p",[a("code",[_._v("Etag / If-None-Match")]),_._v("和"),a("code",[_._v("Last-Modified / If-Modified-Since")]),_._v(";")]),_._v(" "),a("p",[_._v("先来介绍下这两个值的意义和来源；")]),_._v(" "),a("ul",[a("li",[a("h2",{attrs:{id:"etag"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#etag"}},[_._v("#")]),_._v(" ETag")]),_._v(" "),a("p",[_._v("Etag 是服务器响应请求时，返回当前资源文件的一个唯一标识(由服务器生成)")])]),_._v(" "),a("li",[a("h2",{attrs:{id:"if-none-match"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#if-none-match"}},[_._v("#")]),_._v(" If-None-Match")]),_._v(" "),a("p",[_._v("是客户端再次发起该请求时，携带上次请求返回的唯一标识 Etag 值，用以交给服务端判断过程")])])]),_._v(" "),a("h3",{attrs:{id:"过程"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#过程"}},[_._v("#")]),_._v(" 过程")]),_._v(" "),a("p",[_._v("过程是这样的，第一个请求时服务端在响应头中就返回客户端一个"),a("code",[_._v("ETag")]),_._v("，用来表示当前文件的唯一值；")]),_._v(" "),a("p",[_._v("当你再次第二次请求时，浏览器在请求头中加上了"),a("code",[_._v("If-None-Match")]),_._v("这个标头，值就是之前的"),a("code",[_._v("ETag")]),_._v(";")]),_._v(" "),a("p",[_._v("服务端会校验你的"),a("code",[_._v("Etag")]),_._v("是否和最新的文件相同，决定返回 304/200；")]),_._v(" "),a("h2",{attrs:{id:"_4-判断-last-modified"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_4-判断-last-modified"}},[_._v("#")]),_._v(" 4.判断 Last-Modified")]),_._v(" "),a("p",[_._v("和上面"),a("code",[_._v("ETag")]),_._v("相同，浏览器还会增加一组校验标头"),a("code",[_._v("Last-Modified / If-Modified-Since")])]),_._v(" "),a("p",[_._v("这两个值的意义：")]),_._v(" "),a("ul",[a("li",[a("h2",{attrs:{id:"last-modified"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#last-modified"}},[_._v("#")]),_._v(" Last-Modified")]),_._v(" "),a("p",[_._v("Last-Modified 是服务器响应请求时，返回该资源文件在服务器最后被修改的时间")])]),_._v(" "),a("li",[a("h2",{attrs:{id:"if-modified-since"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#if-modified-since"}},[_._v("#")]),_._v(" If-Modified-Since")]),_._v(" "),a("p",[_._v("If-Modified-Since 则是客户端再次发起该请求时，携带上次请求返回的 Last-Modified 值，用以交给服务端判断")])])]),_._v(" "),a("h3",{attrs:{id:"过程-2"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#过程-2"}},[_._v("#")]),_._v(" 过程")]),_._v(" "),a("p",[_._v("和"),a("code",[_._v("ETag")]),_._v("机制相同，都是在响应体中首先拿到保存"),a("code",[_._v("Last-Modified")]),_._v("，在第二次请求中发送"),a("code",[_._v("If-Modified-Since")]),_._v("给服务端；")]),_._v(" "),a("p",[_._v("这里需要注意的是，"),a("code",[_._v("ETag")]),_._v("相比"),a("code",[_._v("Last-Modified")]),_._v("优先级更高；")]),_._v(" "),a("p",[_._v("也就是说，当"),a("code",[_._v("ETag")]),_._v("改变证明文件唯一性已经发生了变化，直接可判断资源更新；")]),_._v(" "),a("p",[_._v("而当"),a("code",[_._v("ETag")]),_._v("没变，再去校验"),a("code",[_._v("Last-Modified")]),_._v("，最后修改时间是否一致；")])])}),[],!1,null,null,null);v.default=t.exports}}]);