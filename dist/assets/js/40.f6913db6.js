(window.webpackJsonp=window.webpackJsonp||[]).push([[40],{390:function(e,t,a){"use strict";a.r(t);var v=a(42),r=Object(v.a)({},(function(){var e=this,t=e.$createElement,a=e._self._c||t;return a("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[a("h2",{attrs:{id:"初始化"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#初始化"}},[e._v("#")]),e._v(" 初始化")]),e._v(" "),a("ul",[a("li",[a("h3",{attrs:{id:"初始化状态-数据"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#初始化状态-数据"}},[e._v("#")]),e._v(" 初始化状态/数据")]),e._v(" "),a("div",{staticClass:"language- line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("new初始化实际是调用了Vue构造函数；并在Vue.prototype上挂载初始化状态/事件；\n")])]),e._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[e._v("1")]),a("br")])])]),e._v(" "),a("li",[a("h3",{attrs:{id:"依赖收集"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#依赖收集"}},[e._v("#")]),e._v(" 依赖收集")]),e._v(" "),a("div",{staticClass:"language- line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("依赖收集主要围绕三个概念类，Observe、Dep、Watcher;\n- Observe类\n首先通过`defineReactive`给每个对象属性增加响应式化（实现为definePorperty）;\n给每个对象属性递归添加getter/setter；\n所以当取值/改值时，触发getter/setter中的Dep依赖收集和派发更新；\n- Dep类\ndep作为依赖搜集器，用来收集Watcher的实例，用来通知更新；\n- Watcher类\nnew实例时（初始化/mount时），添加Dep.target Watcher;\n获取getter时，通过dep.depend添加依赖，\n这里是Dep和Watcher方法间互相调用的过程，Dep中使用保存的`target watcher`去调用`addDep`方法；\nwatcher中的`addDep`方法又用传入的dep实例，调用`addSub`方法来将自身添加到dep依赖中；\n")])]),e._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[e._v("1")]),a("br"),a("span",{staticClass:"line-number"},[e._v("2")]),a("br"),a("span",{staticClass:"line-number"},[e._v("3")]),a("br"),a("span",{staticClass:"line-number"},[e._v("4")]),a("br"),a("span",{staticClass:"line-number"},[e._v("5")]),a("br"),a("span",{staticClass:"line-number"},[e._v("6")]),a("br"),a("span",{staticClass:"line-number"},[e._v("7")]),a("br"),a("span",{staticClass:"line-number"},[e._v("8")]),a("br"),a("span",{staticClass:"line-number"},[e._v("9")]),a("br"),a("span",{staticClass:"line-number"},[e._v("10")]),a("br"),a("span",{staticClass:"line-number"},[e._v("11")]),a("br"),a("span",{staticClass:"line-number"},[e._v("12")]),a("br")])])]),e._v(" "),a("li",[a("h3",{attrs:{id:"挂载-mount"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#挂载-mount"}},[e._v("#")]),e._v(" 挂载 mount")]),e._v(" "),a("div",{staticClass:"language- line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("初始化数据后，实际就是直接调用了`$mount()`方法；\n这个方法多处有定义，实际web端调用的就是`mountComponent()`这个方法；\n新建了一个渲染Watcher，初始化和数据更新的时候都会调用`mountComponent `\n")])]),e._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[e._v("1")]),a("br"),a("span",{staticClass:"line-number"},[e._v("2")]),a("br"),a("span",{staticClass:"line-number"},[e._v("3")]),a("br")])])])]),e._v(" "),a("h2",{attrs:{id:"响应式化"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#响应式化"}},[e._v("#")]),e._v(" 响应式化")]),e._v(" "),a("p",[e._v("上面说过了依赖收集，即只要被依赖的响应式化数据，即被"),a("code",[e._v("defineReactive")]),e._v("；")]),e._v(" "),a("p",[e._v("例如 data、props、computed，就会生成一个"),a("code",[e._v("Dep")]),e._v("实例；用"),a("code",[e._v("dep.depend")]),e._v("来收集它被谁所依赖了；")]),e._v(" "),a("p",[e._v("然后在自身改变的时候回调用"),a("code",[e._v("setting")]),e._v("函数，其中会通过"),a("code",[e._v("dep.notify")]),e._v("来通知所有被它收集依赖的"),a("code",[e._v("watcher")]),e._v("实例；")]),e._v(" "),a("p",[a("code",[e._v("watcher")]),e._v("实例被"),a("code",[e._v("notify")]),e._v("通知后，实际上是调用了自身的"),a("code",[e._v("update")]),e._v("更新函数；")]),e._v(" "),a("p",[e._v("这就形成了响应式化的数据形式；")]),e._v(" "),a("h2",{attrs:{id:"异步更新和-nexttick"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#异步更新和-nexttick"}},[e._v("#")]),e._v(" 异步更新和 nextTick")]),e._v(" "),a("p",[e._v("上面说完了响应式化的数据，当"),a("code",[e._v("watcher")]),e._v("实例被通知"),a("code",[e._v("update")]),e._v("后，其实并不是直接更新数据，并刷新页面 dom；")]),e._v(" "),a("p",[e._v("这里会引入一个概念叫做"),a("strong",[e._v("异步更新")]),e._v("；")]),e._v(" "),a("p",[e._v("也就是被通知更新的操作，会被先进行去重，然后暂时推入一个事件队列中（nextTick）；")]),e._v(" "),a("p",[e._v("也叫做"),a("code",[e._v("eventLoop")]),e._v("，这个队列会直接开启一个浏览器"),a("code",[e._v("microTask")]),e._v("异步微任务；")]),e._v(" "),a("p",[e._v("在执行"),a("code",[e._v("microTask")]),e._v("前或执行中，只要有"),a("code",[e._v("update")]),e._v("更新事件，都可以实时加入到事件"),a("code",[e._v("queue")]),e._v("中，进行更新，但不会再推入"),a("code",[e._v("eventLoop")]),e._v("一个新的微任务；")]),e._v(" "),a("h3",{attrs:{id:"nexttick"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#nexttick"}},[e._v("#")]),e._v(" nextTick")]),e._v(" "),a("p",[e._v("若浏览器开启此异步微任务前，例如使用"),a("code",[e._v("this.$nextTick()")]),e._v(" 再次推入的事件仍然可以加入这个"),a("code",[e._v("tick")]),e._v("中，等开始这个"),a("code",[e._v("mricoTask")]),e._v("时一并进行处理；")]),e._v(" "),a("p",[e._v("但如果已经开始了当前"),a("code",[e._v("microTask")]),e._v("，再使用"),a("code",[e._v("nextTick")]),e._v("加入的事件，就会等到下一个"),a("code",[e._v("microTask")]),e._v("去执行；")]),e._v(" "),a("h2",{attrs:{id:"编译-compile"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#编译-compile"}},[e._v("#")]),e._v(" 编译 compile")]),e._v(" "),a("p",[e._v("compile 就是将"),a("code",[e._v(".vue")]),e._v("单文件"),a("code",[e._v("template")]),e._v("中的 HTML 编译转化为"),a("code",[e._v("render")]),e._v("函数的一个过程；")]),e._v(" "),a("p",[e._v("主要其实就是三步重要的过程: "),a("code",[e._v("parse")]),e._v("、"),a("code",[e._v("optimize")]),e._v("、"),a("code",[e._v("generate")])]),e._v(" "),a("ul",[a("li",[a("code",[e._v("parse")]),e._v("：会用正则等方式解析 template 模板中的指令、class、style 等数据，形成抽象语法树 AST")]),e._v(" "),a("li",[a("code",[e._v("optimize")]),e._v("：优化 AST，生成模板 AST 树，检测不需要进行 DOM 改变的静态子树，减少 patch 的压力")]),e._v(" "),a("li",[a("code",[e._v("generate")]),e._v("：把 AST 生成 render 方法的代码")])]),e._v(" "),a("blockquote",[a("p",[e._v("在"),a("a",{attrs:{href:"https://zh.wikipedia.org/wiki/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6",target:"_blank",rel:"noopener noreferrer"}},[e._v("计算机科学"),a("OutboundLink")],1),e._v("中，"),a("strong",[e._v("抽象语法树")]),e._v("（"),a("strong",[e._v("A")]),e._v("bstract "),a("strong",[e._v("S")]),e._v("yntax "),a("strong",[e._v("T")]),e._v("ree，AST），或简称"),a("strong",[e._v("语法树")]),e._v("（Syntax tree），")]),e._v(" "),a("p",[e._v("是"),a("a",{attrs:{href:"https://zh.wikipedia.org/wiki/%E6%BA%90%E4%BB%A3%E7%A0%81",target:"_blank",rel:"noopener noreferrer"}},[e._v("源代码"),a("OutboundLink")],1),a("a",{attrs:{href:"https://zh.wikipedia.org/wiki/%E8%AF%AD%E6%B3%95%E5%AD%A6",target:"_blank",rel:"noopener noreferrer"}},[e._v("语法"),a("OutboundLink")],1),e._v("结构的一种抽象表示。")]),e._v(" "),a("p",[e._v("它以"),a("a",{attrs:{href:"https://zh.wikipedia.org/wiki/%E6%A0%91_(%E5%9B%BE%E8%AE%BA)",target:"_blank",rel:"noopener noreferrer"}},[e._v("树状"),a("OutboundLink")],1),e._v("的形式表现"),a("a",{attrs:{href:"https://zh.wikipedia.org/wiki/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80",target:"_blank",rel:"noopener noreferrer"}},[e._v("编程语言"),a("OutboundLink")],1),e._v("的语法结构，树上的每个节点都表示源代码中的一种结构。")]),e._v(" "),a("p",[e._v("之所以说语法是“抽象”的，是因为这里的语法并不会表示出真实语法中出现的每个细节。")]),e._v(" "),a("p",[e._v("比如，嵌套括号被隐含在树的结构中，并没有以节点的形式呈现；")]),e._v(" "),a("p",[e._v("而类似于 "),a("code",[e._v("if-condition-then")]),e._v(" 这样的条件跳转语句，可以使用带有三个分支的节点来表示。")])]),e._v(" "),a("h2",{attrs:{id:"patch"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#patch"}},[e._v("#")]),e._v(" patch")]),e._v(" "),a("h2",{attrs:{id:"macrotask-与-microtask-vue-视图更新"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#macrotask-与-microtask-vue-视图更新"}},[e._v("#")]),e._v(" Macrotask 与 Microtask -[vue 视图更新]")]),e._v(" "),a("p",[e._v("`JS 事件循环")]),e._v(" "),a("h2",{attrs:{id:"vnode"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#vnode"}},[e._v("#")]),e._v(" Vnode")]),e._v(" "),a("p",[e._v("Virtual DOM 并没有完全实现 DOM，Virtual DOM 最主要的还是保留了 "),a("code",[e._v("Element")]),e._v(" 之间的层次关系和一些基本属性。实际是使用 JS 对真实 DOM 的一种描述；")]),e._v(" "),a("p",[e._v("其中包含 Virtual DOM 算法，包括几个步骤：")]),e._v(" "),a("ol",[a("li",[e._v("用 JavaScript 对象结构表示 DOM 树的结构；然后用这个树构建一个真正的 DOM 树，插到文档当中")]),e._v(" "),a("li",[e._v("当状态变更的时候，重新构造一棵新的对象树。然后用新的树和旧的树进行比较，记录两棵树差异")]),e._v(" "),a("li",[e._v("把第 2 步所记录的差异应用到第 1 步所构建的真正的 DOM 树上，视图就更新了")])]),e._v(" "),a("h2",{attrs:{id:"dom-diff"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#dom-diff"}},[e._v("#")]),e._v(" dom Diff")]),e._v(" "),a("h2",{attrs:{id:"与-react-异同"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#与-react-异同"}},[e._v("#")]),e._v(" 与 react 异同")]),e._v(" "),a("p",[e._v("vue 的官网中说它是一款渐进式框架，采用自底向上增量开发的设计;")]),e._v(" "),a("p",[e._v("例如做一个单页应用的时候才需要用路由；做一个相当庞大的应用，涉及到多组件状态共享以及多个开发者共同协作时，才可能需要大规模状态管理方案。")]),e._v(" "),a("ul",[a("li",[a("p",[e._v("react 使用自由化度高")]),e._v(" "),a("p",[e._v("vue 入手简单，封装度高，更多的 API")])]),e._v(" "),a("li",[a("p",[e._v("vue 起初的定位就是尽可能的降低前端开发的门槛；")]),e._v(" "),a("p",[e._v("而 react 更多的对原有前端开发模式做出的改变；")])])]),e._v(" "),a("p",[e._v("三大框架数据更新差异")]),e._v(" "),a("p",[e._v("vue - defineproperty 数据劫持（vue3.0 使用 proxy）")]),e._v(" "),a("p",[e._v("angular - 脏检查")]),e._v(" "),a("ul",[a("li",[a("p",[e._v("其实就是存储所有变量的值，每当可能有变量发生变化需要检查时，就将所有变量的旧值跟新值进行比较，"),a("strong",[e._v("不相等就说明检测到变化")]),e._v("，需要更新对应视图。")])]),e._v(" "),a("li",[a("p",[e._v("1.不会脏检查所有的对象。当对象被绑定到 html 中后，这个对象才会添加为检查对象（watcher）")]),e._v(" "),a("p",[e._v("2.不会脏检查所有的属性，同样当属性被绑定后，这个属性才会被列为检查的属性")]),e._v(" "),a("p",[e._v("在 angular 程序初始化时，会将绑定的对象的属性添加为监听对象（watcher），也就是说一个对象绑定了 N 个属性，就会添加 N 个 watcher。")]),e._v(" "),a("p",[e._v("angular 什么时候去脏检查呢？angular 所系统的方法中都会触发比较事件，比如：controller 初始化的时候，所有以 ng-开头的事件爱你执行后，都会出发脏检查")])])]),e._v(" "),a("p",[e._v("react - 单向数据流")]),e._v(" "),a("p",[e._v("和 vue 一样都是由父组件向子组件传值，但是 vue 实现的数据双向绑定实际上是语法糖；")])])}),[],!1,null,null,null);t.default=r.exports}}]);