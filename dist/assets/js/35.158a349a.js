(window.webpackJsonp=window.webpackJsonp||[]).push([[35],{364:function(e,s,a){"use strict";a.r(s);var t=a(42),r=Object(t.a)({},(function(){var e=this,s=e.$createElement,a=e._self._c||s;return a("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[a("h2",{attrs:{id:"_1-promise"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_1-promise"}},[e._v("#")]),e._v(" 1.Promise")]),e._v(" "),a("p",[e._v("先了解一下 Promise/a+规范内容：")]),e._v(" "),a("ol",[a("li",[a("p",[e._v("这个 promise 有三种状态：")]),e._v(" "),a("p",[e._v("Promise 的初始状态为 pending，它可以由此状态转换为 fulfilled（本文为了一致把此状态叫做 resolved）或者 rejected，一旦状态确定，就不可以再次转换为其它状态，状态确定的过程称为 settle")])]),e._v(" "),a("li",[a("p",[e._v("then 方法返回一个新的 Promise，Promise 的 then 方法返回一个新的 Promise，而不是返回 this，此处在下文会有更多解释；")])]),e._v(" "),a("li",[a("p",[e._v("只有一个 then 方法，并通过 then 调用，没有 catch，race，all 等方法，甚至没有构造函数；")])])]),e._v(" "),a("h3",{attrs:{id:"promise-的实现"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#promise-的实现"}},[e._v("#")]),e._v(" Promise 的实现")]),e._v(" "),a("p",[e._v("因为他只是一个规范，所以在不同的框架或者平台下有不同的实现")]),e._v(" "),a("ul",[a("li",[a("p",[e._v("Angular：$q 服务")])]),e._v(" "),a("li",[a("p",[e._v("Node：q 模块，co，then")])]),e._v(" "),a("li",[a("p",[e._v("Es6: Promise, yield")])]),e._v(" "),a("li",[a("p",[e._v("Es7： async await")])])]),e._v(" "),a("h3",{attrs:{id:"解决痛点"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#解决痛点"}},[e._v("#")]),e._v(" 解决痛点：")]),e._v(" "),a("p",[e._v("由于 JavaScript 语言特性是由事件驱动，所有程序都是单线程执行的（由浏览器决定）；")]),e._v(" "),a("p",[e._v("所以在解决异步问题上，例如浏览器事件，都是通过"),a("strong",[e._v("回调函数")]),e._v("来处理异步结果；")]),e._v(" "),a("p",[e._v("当场景复杂多层嵌套后，就会形成所谓的"),a("strong",[e._v("回调地狱")]),e._v("；")]),e._v(" "),a("p",[e._v("为了解决这种问题，社区提出了一些解决方案，采用"),a("strong",[e._v("链式调用")]),e._v("的方法来解决异步回调；")]),e._v(" "),a("p",[e._v("也就是 Promise，并被加入 ES6 标准。")]),e._v(" "),a("h3",{attrs:{id:"使用"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#使用"}},[e._v("#")]),e._v(" 使用：")]),e._v(" "),a("p",[e._v("Promise 作为一个构造函数，使用"),a("code",[e._v("new")]),e._v("来创建实例，接受一个初始化函数作为参数；")]),e._v(" "),a("p",[e._v("这个初始化函数有两个参数"),a("code",[e._v("resolve/reject")]),e._v("，可供调用"),a("code",[e._v("Promise")]),e._v("构造函数中的两个处理函数；")]),e._v(" "),a("div",{staticClass:"language- line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v(" const promise = new Promise((resolve, reject) => {\n   resolve('fulfilled'); // 状态由 pending => fulfilled\n })\n")])]),e._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[e._v("1")]),a("br"),a("span",{staticClass:"line-number"},[e._v("2")]),a("br"),a("span",{staticClass:"line-number"},[e._v("3")]),a("br")])]),a("p",[e._v("resolve 返回出的结果，可以在"),a("code",[e._v("then")]),e._v("中进行结果处理；")]),e._v(" "),a("p",[a("code",[e._v("then()")]),e._v("其实是在为"),a("code",[e._v("Promise")]),e._v("中的 callback 注册回调函数，回调函数并没有直接执行，而是在 resolve 后才执行，所以可以获取结果进行处理；")]),e._v(" "),a("h3",{attrs:{id:"链式调用"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#链式调用"}},[e._v("#")]),e._v(" 链式调用：")]),e._v(" "),a("p",[e._v("链式调用里 then 中的函数一定要 return 一个结果或者一个新的 Promise 对象，")]),e._v(" "),a("p",[e._v("才可以让之后的 then 回调接收。")]),e._v(" "),a("h3",{attrs:{id:"原理"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#原理"}},[e._v("#")]),e._v(" 原理：")]),e._v(" "),a("p",[a("code",[e._v("then")])]),e._v(" "),a("h3",{attrs:{id:"示例"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#示例"}},[e._v("#")]),e._v(" 示例：")]),e._v(" "),a("div",{staticClass:"language- line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("https://www.jianshu.com/p/559d25c88670 复杂案例\n")])]),e._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[e._v("1")]),a("br")])]),a("h2",{attrs:{id:"_2-事件驱动"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_2-事件驱动"}},[e._v("#")]),e._v(" 2.事件驱动")]),e._v(" "),a("p",[e._v("js 在浏览器端是单线程的，也注定是单线程，因为浏览器主要作为与用户的交互端；")]),e._v(" "),a("p",[e._v("如果是多线程，可能会造成复杂的操作问题，例如两个线程同时操作同一个 DOM，那么浏览器会无法进行；")]),e._v(" "),a("p",[e._v("从一诞生，JavaScript 就是单线程，这已经成了这门语言的核心特征，将来也不会改变；")]),e._v(" "),a("blockquote",[a("p",[e._v("-- 百科解释")]),e._v(" "),a("p",[e._v("事件驱动程序设计（英语：Event-driven programming）是一种电脑程序设计模型。这种模型的程序运行流程是由用户的动作（如鼠标的按键，键盘的按键动作）或者是由其他程序的消息来决定的。")]),e._v(" "),a("p",[e._v("相对于批处理程序设计（batch programming）而言，程序运行的流程是由程序员来决定。批量的程序设计在初级程序设计教学课程上是一种方式。然而，事件驱动程序设计这种设计模型是在交互程序（Interactive program）的情况下孕育而生的")])]),e._v(" "),a("h3",{attrs:{id:"进程与线程"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#进程与线程"}},[e._v("#")]),e._v(" 进程与线程")]),e._v(" "),a("p",[e._v("进程是操作系统分配资源和调度任务的基本单位，线程是建立在进程上的一次程序运行单位，一个进程上可以有多个线程。")]),e._v(" "),a("ol",[a("li",[e._v("浏览器线程\n"),a("ul",[a("li",[e._v("用户界面-包括地址栏、前进/后退按钮、书签菜单等")]),e._v(" "),a("li",[e._v("浏览器引擎-在用户界面和呈现引擎之间传送指令(浏览器的主进程)")]),e._v(" "),a("li",[e._v("渲染引擎，也被称为浏览器内核(浏览器渲染进程)")]),e._v(" "),a("li",[e._v("一个插件对应一个进程(第三方插件进程)")]),e._v(" "),a("li",[e._v("GPU 提高网页浏览的体验( GPU 进程)")])])]),e._v(" "),a("li",[e._v("浏览器渲染引擎\n"),a("ul",[a("li",[e._v("渲染引擎内部是多线程的，内部包含 ui 线程和 js 线程")]),e._v(" "),a("li",[e._v("js 线程 ui 线程 这两个线程互斥的，目的就是为了保证不产生冲突。")]),e._v(" "),a("li",[e._v("ui 线程会把更改的放到队列中，当 js 线程空闲下来的时候，ui 线程在继续渲染")])])]),e._v(" "),a("li",[e._v("js 单线程\n"),a("ul",[a("li",[e._v("js 是单线程，为什么呢？如果多个线程同时操作 DOM ，哪页面不会很混乱？这里所谓的单线程指的是主线程是单线程的,所以在 Node 中主线程依旧是单线程的。")])])]),e._v(" "),a("li",[e._v("webworker 多线程\n"),a("ul",[a("li",[e._v("它和 js 主线程不是平级的，主线程可以控制 webworker，但是 webworker 不能操作 DOM，不能获取 document，window")])])]),e._v(" "),a("li",[e._v("其他线程\n"),a("ul",[a("li",[e._v("浏览器事件触发线程(用来控制事件循环,存放 setTimeout、浏览器事件、ajax 的回调函数)")]),e._v(" "),a("li",[e._v("定时触发器线程(setTimeout 定时器所在线程)")]),e._v(" "),a("li",[e._v("异步 HTTP 请求线程(ajax 请求线程)")])])])]),e._v(" "),a("blockquote",[a("p",[e._v("单线程特点是节约了内存,并且不需要在切换执行上下文。而且单线程不需要管锁的问题,所谓 锁，在 java 里才有锁的概念，所以我们不用细研究")])]),e._v(" "),a("h2",{attrs:{id:"_3-事件循环"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_3-事件循环"}},[e._v("#")]),e._v(" 3.事件循环")]),e._v(" "),a("p",[e._v('事件循环的步骤：\n（1）所有同步任务都在主线程上执行，形成一个执行栈（execution context stack）。\n（2）主线程之外，还存在一个"任务队列"（task queue）。只要异步任务有了运行结果，就在"任务队列"之中放置一个事件。\n（3）一旦"执行栈"中的所有同步任务执行完毕，系统就会读取"任务队列"，看看里面有哪些事件。那些对应的异步任务，于是结束等待状态，进入执行栈，开始执行。\n（4）主线程不断重复上面的第三步。')]),e._v(" "),a("p",[e._v("一个线程中，事件循环是唯一的，但是任务队列可以有多个;")]),e._v(" "),a("ul",[a("li",[a("p",[e._v("任务队列又分为 macro-task（宏任务）和 micro-task（微任务）;")])]),e._v(" "),a("li",[a("p",[e._v("macro-task 大概包括：")]),e._v(" "),a("div",{staticClass:"language- line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("script（整体代码）,\nsetTimeout,\nsetInterval,\nsetImmediate,\nI/O,\nUI rendering;\n")])]),e._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[e._v("1")]),a("br"),a("span",{staticClass:"line-number"},[e._v("2")]),a("br"),a("span",{staticClass:"line-number"},[e._v("3")]),a("br"),a("span",{staticClass:"line-number"},[e._v("4")]),a("br"),a("span",{staticClass:"line-number"},[e._v("5")]),a("br"),a("span",{staticClass:"line-number"},[e._v("6")]),a("br")])])]),e._v(" "),a("li",[a("p",[e._v("micro-task 大概包括：")]),e._v(" "),a("div",{staticClass:"language- line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("process.nextTick,\nPromise,\nObject.observe(已废弃),\nMutationObserver(html5新特性)\n")])]),e._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[e._v("1")]),a("br"),a("span",{staticClass:"line-number"},[e._v("2")]),a("br"),a("span",{staticClass:"line-number"},[e._v("3")]),a("br"),a("span",{staticClass:"line-number"},[e._v("4")]),a("br")])])]),e._v(" "),a("li",[a("p",[e._v("事件循环的顺序，决定了 JavaScript 代码的执行顺序。它从 script(整体代码)开始第一次循环。之后全局上下文进入函数调用栈。直到调用栈清空(只剩全局)，然后执行所有的 micro-task。当所有可执行的 micro-task 执行完毕之后。循环再次从 macro-task 开始，找到其中一个任务队列执行完毕，然后再执行所有的 micro-task，这样一直循环下去。")])])]),e._v(" "),a("h2",{attrs:{id:"_4-es6-运行环境"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_4-es6-运行环境"}},[e._v("#")]),e._v(" 4.ES6 运行环境")]),e._v(" "),a("p",[e._v("虽然目前大部分主流浏览器都支持了 es6 语法，但仍不能保证所有用户浏览器都支持；")]),e._v(" "),a("p",[e._v("所以我们需要使用"),a("code",[e._v("babel")]),e._v("来进行编译，让 ES5+的语法都能编译为 ES5 运行在所有浏览器上；")]),e._v(" "),a("p",[e._v("起初是为了兼容性，但后来更多是为了让 es 规范可以更大刀阔斧的添加新特性，因为我们有编译！；")]),e._v(" "),a("p",[a("code",[e._v("tc39")]),e._v("渐进式的演进模式，浏览器根本跟不上新特性的步伐，而 babel 存在，可以让"),a("code",[e._v("tc39")]),e._v("没有包袱的前进。")]),e._v(" "),a("blockquote",[a("h4",{attrs:{id:"tc39-是什么-包括哪些人"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#tc39-是什么-包括哪些人"}},[e._v("#")]),e._v(" TC39 是什么？包括哪些人？")]),e._v(" "),a("p",[e._v("「TC39」全称「Technical Committee 39」译为「第 39 号技术委员会」，是 Ecma 组织架构中的一部分。")]),e._v(" "),a("p",[e._v("一个推动 JavaScript 发展的委员会，由各个主流浏览器厂商的代表构成。")]),e._v(" "),a("h4",{attrs:{id:"tc39-这群人主要的工作是什么"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#tc39-这群人主要的工作是什么"}},[e._v("#")]),e._v(" TC39 这群人主要的工作是什么？")]),e._v(" "),a("p",[e._v("制定 ECMAScript 标准，标准生成的流程，并实现。")]),e._v(" "),a("h4",{attrs:{id:"ecma-是什么"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#ecma-是什么"}},[e._v("#")]),e._v(" ECMA 是什么")]),e._v(" "),a("p",[e._v("ECMA 就是欧洲计算机制造协会的简称："),a("code",[e._v("European Computer Manufacturers Association")])])]),e._v(" "),a("h2",{attrs:{id:"_5-模块系统"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_5-模块系统"}},[e._v("#")]),e._v(" 5.模块系统")]),e._v(" "),a("h3",{attrs:{id:"意义"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#意义"}},[e._v("#")]),e._v(" 意义：")]),e._v(" "),a("p",[e._v("就是将一个复杂的程序，依据一定的规则(规范)封装成几个块(文件), 并进行组合在一起，通常只是向外部暴露一些接口(方法)与外部其它模块通信；")]),e._v(" "),a("p",[e._v("本质是一种复杂度管理的手段技术。")]),e._v(" "),a("h3",{attrs:{id:"实现方案"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#实现方案"}},[e._v("#")]),e._v(" 实现方案：")]),e._v(" "),a("ul",[a("li",[a("p",[a("code",[e._v("AMD/CMD")])]),e._v(" "),a("p",[e._v("AMD 作为模块加载器，可以在浏览器环境中异步加载多个模块，解决了"),a("code",[e._v("COMMONJS")]),e._v("同步加载模块的问题；")]),e._v(" "),a("p",[e._v("使用"),a("code",[e._v("注入依赖")]),e._v("的思想，需要在引用模块的文件中写明依赖的模块；")]),e._v(" "),a("div",{staticClass:"language- line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("//demo.js\n(function(){\n    //配置每个变量对应的模块路径\n    require.config({\n        paths: {\n            m1: './modules/m1',\n            m2: './modules/m2',\n            jquery:'./jquery-3.3.1'\n        }\n    })\n    require(['m2','jquery'],function(m2,$){\n        m2.show(); //结果：m2-amd m1-amd\n        $('body').css('backgroundColor','#000');\n    })\n})()\n")])]),e._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[e._v("1")]),a("br"),a("span",{staticClass:"line-number"},[e._v("2")]),a("br"),a("span",{staticClass:"line-number"},[e._v("3")]),a("br"),a("span",{staticClass:"line-number"},[e._v("4")]),a("br"),a("span",{staticClass:"line-number"},[e._v("5")]),a("br"),a("span",{staticClass:"line-number"},[e._v("6")]),a("br"),a("span",{staticClass:"line-number"},[e._v("7")]),a("br"),a("span",{staticClass:"line-number"},[e._v("8")]),a("br"),a("span",{staticClass:"line-number"},[e._v("9")]),a("br"),a("span",{staticClass:"line-number"},[e._v("10")]),a("br"),a("span",{staticClass:"line-number"},[e._v("11")]),a("br"),a("span",{staticClass:"line-number"},[e._v("12")]),a("br"),a("span",{staticClass:"line-number"},[e._v("13")]),a("br"),a("span",{staticClass:"line-number"},[e._v("14")]),a("br"),a("span",{staticClass:"line-number"},[e._v("15")]),a("br")])])]),e._v(" "),a("li",[a("p",[a("code",[e._v("COMMONJS")])]),e._v(" "),a("p",[a("code",[e._v("CommonJS")]),e._v("规范是 Node 独有的模块规范；")]),e._v(" "),a("p",[a("code",[e._v("CommonJS")]),e._v("规范加载模块是"),a("strong",[e._v("同步")]),e._v("的，也就是说，只有加载完成，才能执行后面的操作。")]),e._v(" "),a("div",{staticClass:"language- line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("// a.js\nmodule.exports = {\n    a: 1\n}\n// or\nexports.a = 1\n\n// b.js\nvar module = require('./a.js')\nmodule.a // -> log 1\n")])]),e._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[e._v("1")]),a("br"),a("span",{staticClass:"line-number"},[e._v("2")]),a("br"),a("span",{staticClass:"line-number"},[e._v("3")]),a("br"),a("span",{staticClass:"line-number"},[e._v("4")]),a("br"),a("span",{staticClass:"line-number"},[e._v("5")]),a("br"),a("span",{staticClass:"line-number"},[e._v("6")]),a("br"),a("span",{staticClass:"line-number"},[e._v("7")]),a("br"),a("span",{staticClass:"line-number"},[e._v("8")]),a("br"),a("span",{staticClass:"line-number"},[e._v("9")]),a("br"),a("span",{staticClass:"line-number"},[e._v("10")]),a("br")])])]),e._v(" "),a("li",[a("p",[a("code",[e._v("ES6")])]),e._v(" "),a("p",[e._v("使用简单，静态化设计思想，编译时就可确定依赖关系；足以取代上述两种方案；")]),e._v(" "),a("p",[e._v("目前需要"),a("code",[e._v("babal")]),e._v("编译；")]),e._v(" "),a("div",{staticClass:"language- line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("// 导出\nexport function hello() { };\nexport default {\n  // ...\n};\n// 导入\nimport { readFile } from 'fs';\nimport React from 'react';\n")])]),e._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[e._v("1")]),a("br"),a("span",{staticClass:"line-number"},[e._v("2")]),a("br"),a("span",{staticClass:"line-number"},[e._v("3")]),a("br"),a("span",{staticClass:"line-number"},[e._v("4")]),a("br"),a("span",{staticClass:"line-number"},[e._v("5")]),a("br"),a("span",{staticClass:"line-number"},[e._v("6")]),a("br"),a("span",{staticClass:"line-number"},[e._v("7")]),a("br"),a("span",{staticClass:"line-number"},[e._v("8")]),a("br")])])])]),e._v(" "),a("h3",{attrs:{id:"总结"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#总结"}},[e._v("#")]),e._v(" 总结：")]),e._v(" "),a("p",[e._v("模块化本质是在管理程序复杂度，JS 模块化的演进另一方面也说明了 Web 的能力在不断增强，Web 应用日趋复杂。")]),e._v(" "),a("p",[e._v("相信未来 JS 的能力进一步提升，我们的开发效率也会更加高效。")]),e._v(" "),a("h2",{attrs:{id:"_6-proxy-reflect"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_6-proxy-reflect"}},[e._v("#")]),e._v(" 6.Proxy / Reflect")]),e._v(" "),a("p",[e._v("两个都是 ES6 新增的 API，proxy 作用是可以用来定义对象各种基本操作的自定义行为；")]),e._v(" "),a("p",[e._v("可以改变 JS 默认的一些语言行为，包括拦截默认的 get/set 等底层方法，使得 JS 的使用自由度更高")]),e._v(" "),a("p",[e._v("也能相当于对象或函数的浅拷贝，修改 target，可以对响应的代理 proxy 自定义操作；")]),e._v(" "),a("div",{staticClass:"language- line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("let target = { age: 18, name: 'Niko Bellic' }\nlet handlers = {\n  get (target, property) {\n    return `${property}: ${target[property]}`\n  },\n  set (target, property, value) {\n    target[property] = value\n  }\n}\nlet proxy = new Proxy(target, handlers)\n\nproxy.age = 19\nconsole.log(target.age, proxy.age)   // 19,          age : 19\nconsole.log(target.name, proxy.name) // Niko Bellic, name: Niko Bellic\n")])]),e._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[e._v("1")]),a("br"),a("span",{staticClass:"line-number"},[e._v("2")]),a("br"),a("span",{staticClass:"line-number"},[e._v("3")]),a("br"),a("span",{staticClass:"line-number"},[e._v("4")]),a("br"),a("span",{staticClass:"line-number"},[e._v("5")]),a("br"),a("span",{staticClass:"line-number"},[e._v("6")]),a("br"),a("span",{staticClass:"line-number"},[e._v("7")]),a("br"),a("span",{staticClass:"line-number"},[e._v("8")]),a("br"),a("span",{staticClass:"line-number"},[e._v("9")]),a("br"),a("span",{staticClass:"line-number"},[e._v("10")]),a("br"),a("span",{staticClass:"line-number"},[e._v("11")]),a("br"),a("span",{staticClass:"line-number"},[e._v("12")]),a("br"),a("span",{staticClass:"line-number"},[e._v("13")]),a("br"),a("span",{staticClass:"line-number"},[e._v("14")]),a("br")])]),a("p",[e._v("target 是源对象，你设置的"),a("code",[e._v("handler")]),e._v("，在修改 target 的同时可以自定义 proxy 的结果；")]),e._v(" "),a("p",[e._v("例如上面例子中，"),a("code",[e._v("get")]),e._v("的 handler 中返回了拼接后的"),a("code",[e._v("${property}: ${target[property]}")]),e._v("，这个返回值其实返回给了 new 代理的 proxy 实例；")]),e._v(" "),a("p",[e._v("打个比方就是：")]),e._v(" "),a("p",[e._v("可以理解为，有一个很火的明星，开通了一个微博账号，这个账号非常活跃，回复粉丝、到处点赞之类的，但可能并不是真的由本人在维护的。\n而是在背后有一个其他人 or 团队来运营，我们就可以称他们为代理人，因为他们发表的微博就代表了明星本人的意思。")]),e._v(" "),a("p",[e._v("这个"),a("strong",[e._v("代理运营团队")]),e._v("就是"),a("code",[e._v("proxy")]),e._v("， 而明星"),a("strong",[e._v("本人")]),e._v("就是"),a("code",[e._v("target")]),e._v("；")]),e._v(" "),a("h3",{attrs:{id:"reflect"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#reflect"}},[e._v("#")]),e._v(" Reflect")]),e._v(" "),a("p",[e._v("Reflect 是 ES6 引入的一个新的对象，")]),e._v(" "),a("p",[a("strong",[e._v("他的主要作用有两点")]),e._v("，一是将原生的一些零散分布在 Object、Function 或者全局函数里的方法(如 apply、delete、get、set 等等)，统一整合到 Reflect 上，这样可以更加方便更加统一的管理一些原生 API。")]),e._v(" "),a("p",[e._v("其次就是因为 Proxy 可以改写默认的原生 API，如果一旦原生 API 别改写可能就找不到了，所以 Reflect 也可以起到备份原生 API 的作用，使得即使原生 API 被改写了之后，也可以在被改写之后的 API 用上默认的 API。")]),e._v(" "),a("h2",{attrs:{id:"_7-es6-的优化-新增"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_7-es6-的优化-新增"}},[e._v("#")]),e._v(" 7.ES6 的优化/新增")]),e._v(" "),a("h3",{attrs:{id:"string"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#string"}},[e._v("#")]),e._v(" String")]),e._v(" "),a("ul",[a("li",[e._v("模板字符串")]),e._v(" "),a("li",[e._v("String.includes()")])]),e._v(" "),a("h3",{attrs:{id:"array"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#array"}},[e._v("#")]),e._v(" Array")]),e._v(" "),a("ul",[a("li",[e._v("解构赋值")]),e._v(" "),a("li",[e._v("扩展运算符")]),e._v(" "),a("li",[e._v("Array.find()")])]),e._v(" "),a("h3",{attrs:{id:"object"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#object"}},[e._v("#")]),e._v(" Object")]),e._v(" "),a("ul",[a("li",[a("p",[e._v("对象解构赋值")])]),e._v(" "),a("li",[a("p",[e._v("变量式声明属性")]),e._v(" "),a("div",{staticClass:"language- line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("let es5Fun = {\n    method: function(){}\n};\nlet es6Fun = {\n    method(){}\n}\n")])]),e._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[e._v("1")]),a("br"),a("span",{staticClass:"line-number"},[e._v("2")]),a("br"),a("span",{staticClass:"line-number"},[e._v("3")]),a("br"),a("span",{staticClass:"line-number"},[e._v("4")]),a("br"),a("span",{staticClass:"line-number"},[e._v("5")]),a("br"),a("span",{staticClass:"line-number"},[e._v("6")]),a("br")])])]),e._v(" "),a("li",[a("p",[e._v("扩展运算符")])]),e._v(" "),a("li",[a("p",[e._v("Object.assign()")])]),e._v(" "),a("li",[a("p",[e._v("Object.keys()")])])]),e._v(" "),a("h3",{attrs:{id:"function"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#function"}},[e._v("#")]),e._v(" Function")]),e._v(" "),a("ul",[a("li",[a("p",[e._v("箭头函数")]),e._v(" "),a("p",[a("strong",[e._v("箭头函数内的 this 指向的是函数定义时所在的对象，而不是函数执行时所在的对象")])]),e._v(" "),a("p",[e._v("ES5 函数里的 this 总是指向函数执行时所在的对象，这使得在很多情况下 this 的指向变得很难理解，尤其是非严格模式情况下，this 有时候会指向全局对象，这甚至也可以归结为语言层面的 bug 之一")])]),e._v(" "),a("li")]),e._v(" "),a("h3",{attrs:{id:"number"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#number"}},[e._v("#")]),e._v(" Number")]),e._v(" "),a("ul",[a("li",[e._v("优化 Number.isNaN()")])]),e._v(" "),a("h3",{attrs:{id:"symbol"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#symbol"}},[e._v("#")]),e._v(" Symbol")]),e._v(" "),a("p",[e._v("Symbol 是 ES6 引入的第七种原始数据类型,所有 Symbol()生成的值都是"),a("strong",[e._v("独一无二")]),e._v("的")]),e._v(" "),a("p",[e._v("可以从根本上解决对象属性太多导致"),a("strong",[e._v("属性名冲突")]),e._v("覆盖的问题。对象中 Symbol()属性"),a("strong",[e._v("不能被 for...in 遍历")])]),e._v(" "),a("h3",{attrs:{id:"set"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#set"}},[e._v("#")]),e._v(" Set")]),e._v(" "),a("p",[a("strong",[e._v("解决痛点：轻松去重，效率提升")])]),e._v(" "),a("p",[e._v("Set 是 ES6 引入的一种"),a("strong",[e._v("类似 Array")]),e._v("的新的数据结构，Set 实例的成员类似于数组 item 成员，区别是 Set 实例的成员都是"),a("strong",[e._v("唯一")]),e._v("，不重复的。这个特性可以轻松地实现数组去重。")]),e._v(" "),a("div",{staticClass:"language- line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v('const duplicateCollection = [\'A\', \'B\', \'B\', \'C\', \'D\', \'B\', \'C\'];\n// 将数组转换为 Set\nlet uniqueCollection = new Set(duplicateCollection);\nconsole.log(uniqueCollection) // Result: Set(4) {"A", "B", "C", "D"}\n// 值保存在数组中\nlet uniqueCollection = [...new Set(duplicateCollection)];\nconsole.log(uniqueCollection) // Result: ["A", "B", "C", "D"]\n')])]),e._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[e._v("1")]),a("br"),a("span",{staticClass:"line-number"},[e._v("2")]),a("br"),a("span",{staticClass:"line-number"},[e._v("3")]),a("br"),a("span",{staticClass:"line-number"},[e._v("4")]),a("br"),a("span",{staticClass:"line-number"},[e._v("5")]),a("br"),a("span",{staticClass:"line-number"},[e._v("6")]),a("br"),a("span",{staticClass:"line-number"},[e._v("7")]),a("br")])]),a("p",[e._v("相比 Array 来说，Set 操作效率更高，方法更简洁；")]),e._v(" "),a("p",[e._v("因为和 Array 相比之下，"),a("code",[e._v("set")]),e._v("是一个键的集合。"),a("code",[e._v("set")]),e._v("不使用索引，而是使用键对数据排序。")]),e._v(" "),a("p",[a("code",[e._v("set")]),e._v(" 中的元素按插入顺序是可迭代的，它不能包含任何重复的数据。换句话说，"),a("code",[e._v("set")]),e._v("中的每一项都必须是惟一的。")]),e._v(" "),a("p",[a("code",[e._v("set")]),e._v(" 相对于数组有几个优势，特别是在运行时间方面：")]),e._v(" "),a("ul",[a("li",[a("strong",[e._v("查看元素")]),e._v("：使用"),a("code",[e._v("indexOf()")]),e._v("或"),a("code",[e._v("includes()")]),e._v("检查数组中的项是否存在是比较慢的。")]),e._v(" "),a("li",[a("strong",[e._v("删除元素")]),e._v(":在"),a("code",[e._v("Set")]),e._v("中，可以根据每项的的 "),a("code",[e._v("value")]),e._v(" 来删除该项。在数组中，等价的方法是使用基于元素的索引的"),a("code",[e._v("splice()")]),e._v("。与前一点一样，依赖于索引的速度很慢。")]),e._v(" "),a("li",[a("strong",[e._v("保存 NaN")]),e._v("：不能使用"),a("code",[e._v("indexOf()")]),e._v("或 "),a("code",[e._v("includes()")]),e._v(" 来查找值 "),a("code",[e._v("NaN")]),e._v("，而 "),a("code",[e._v("Set")]),e._v(" 可以保存此值。")]),e._v(" "),a("li",[a("strong",[e._v("删除重复项")]),e._v(":"),a("code",[e._v("Set")]),e._v("对象只存储惟一的值,如果不想有重复项存在，相对于数组的一个显著优势，因为数组需要额外的代码来处理重复。")])]),e._v(" "),a("h3",{attrs:{id:"map"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#map"}},[e._v("#")]),e._v(" Map")]),e._v(" "),a("p",[e._v("解决痛点："),a("strong",[e._v("key 值不限于 string，有序排列，统一遍历方法，API 方便")])]),e._v(" "),a("p",[e._v("Map 是 ES6 引入的一种"),a("strong",[e._v("类似 Object")]),e._v("的新的数据结构，Map 可以理解为是"),a("strong",[e._v("Object 的超集")]),e._v("，打破了以传统键值对形式定义对象，"),a("strong",[e._v("对象的 key 不再局限于字符串")]),e._v("，也可以是 Object。可以更加全面的描述对象的属性。")]),e._v(" "),a("ul",[a("li",[e._v("一个"),a("code",[e._v("Object")]),e._v(" 的键只能是字符串或者 "),a("code",[e._v("Symbols")]),e._v("，但一个"),a("code",[e._v("Map")]),e._v(" 的键可以是任意值。")]),e._v(" "),a("li",[a("code",[e._v("Map")]),e._v("中的键值是"),a("strong",[e._v("有序的")]),e._v("（FIFO 先进先出原则），而添加到对象中的键则不是。")]),e._v(" "),a("li",[a("code",[e._v("Map")]),e._v("的键值对个数可以从 size 属性获取，而 "),a("code",[e._v("Object")]),e._v(" 的键值对个数只能手动计算。")]),e._v(" "),a("li",[e._v("合并两个 Map 对象时，如果有重复的键值，则"),a("strong",[e._v("后面的会覆盖前面")]),e._v("的。")])]),e._v(" "),a("h2",{attrs:{id:"_8-for-of"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_8-for-of"}},[e._v("#")]),e._v(" 8. for...of")]),e._v(" "),a("h3",{attrs:{id:"解决痛点-2"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#解决痛点-2"}},[e._v("#")]),e._v(" 解决痛点：")]),e._v(" "),a("p",[e._v("Iterator 接口的目的就是为所有数据结构，"),a("strong",[e._v("提供了一种统一的访问机制")]),e._v("，即"),a("code",[e._v("for...of")]),e._v("循环。")]),e._v(" "),a("p",[e._v("当使用"),a("code",[e._v("for...of")]),e._v("循环遍历某种数据结构时，该循环会自动去寻找 Iterator 接口。")]),e._v(" "),a("p",[e._v("一个数据结构只要部署了"),a("code",[e._v("Symbol.iterator")]),e._v("属性，就被视为具有 iterator 接口，就可以用 for...of 循环遍历它的成员。")]),e._v(" "),a("p",[e._v("也就是说，for...of 循环内部调用的是数据结构的"),a("code",[e._v("Symbol.iterator")]),e._v("方法。")]),e._v(" "),a("p",[a("strong",[e._v("Iterator 接口主要供 for...of 消费， 且 for...of 循环需要有"),a("code",[e._v("iterator接口")]),e._v("。")])]),e._v(" "),a("div",{staticClass:"language- line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("// 模拟Iterator接口\n\nlet it = makeIterator(['a','b']);\n\nit.next();// { value: \"a\", done: false }\nit.next();// { value: \"b\", done: false }\nit.next();// { value: undefined, done: true }\n\nfucntion makeIterator(array){\n    let nextIndex = 0;\n    return {\n        next : function(){\n            return nextInedx < array.length ?\n            {value : array[nextIndex++], done : false} :\n            {value : undefined, done : true};\n        }\n    }\n}\n")])]),e._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[e._v("1")]),a("br"),a("span",{staticClass:"line-number"},[e._v("2")]),a("br"),a("span",{staticClass:"line-number"},[e._v("3")]),a("br"),a("span",{staticClass:"line-number"},[e._v("4")]),a("br"),a("span",{staticClass:"line-number"},[e._v("5")]),a("br"),a("span",{staticClass:"line-number"},[e._v("6")]),a("br"),a("span",{staticClass:"line-number"},[e._v("7")]),a("br"),a("span",{staticClass:"line-number"},[e._v("8")]),a("br"),a("span",{staticClass:"line-number"},[e._v("9")]),a("br"),a("span",{staticClass:"line-number"},[e._v("10")]),a("br"),a("span",{staticClass:"line-number"},[e._v("11")]),a("br"),a("span",{staticClass:"line-number"},[e._v("12")]),a("br"),a("span",{staticClass:"line-number"},[e._v("13")]),a("br"),a("span",{staticClass:"line-number"},[e._v("14")]),a("br"),a("span",{staticClass:"line-number"},[e._v("15")]),a("br"),a("span",{staticClass:"line-number"},[e._v("16")]),a("br"),a("span",{staticClass:"line-number"},[e._v("17")]),a("br"),a("span",{staticClass:"line-number"},[e._v("18")]),a("br")])]),a("h2",{attrs:{id:"interator-接口"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#interator-接口"}},[e._v("#")]),e._v(" Interator 接口")]),e._v(" "),a("p",[e._v("Iterator 是 ES6 中一个很重要概念，它并不是对象，也不是任何一种数据类型。")]),e._v(" "),a("p",[e._v("因为 ES6 新增了 Set、Map 类型，他们和 Array、Object 类型很像，Array、Object 都是可以遍历的，但是 Set、Map 都不能用 for 循环遍历；")]),e._v(" "),a("p",[e._v("所以为了统一所有可遍历类型的遍历方式，Interator 就是这样一种标准；")]),e._v(" "),a("h3",{attrs:{id:"原生接口"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#原生接口"}},[e._v("#")]),e._v(" 原生接口")]),e._v(" "),a("p",[e._v("ES6 的有些数据结构原生具备 Iterator 接口（比如数组），即不用任何处理，就可以被 for...of 循环遍历。")]),e._v(" "),a("p",[e._v("具备原生接口的类型：")]),e._v(" "),a("ul",[a("li",[e._v("Array")]),e._v(" "),a("li",[e._v("Map")]),e._v(" "),a("li",[e._v("Set")]),e._v(" "),a("li",[e._v("String")]),e._v(" "),a("li",[e._v("TypedArray")]),e._v(" "),a("li",[e._v("函数的 arguments 对象")]),e._v(" "),a("li",[e._v("NodeList 对象")])]),e._v(" "),a("p",[e._v("以上类型可以原生使用"),a("code",[e._v("for...of")]),e._v("循环，但不包括对象"),a("code",[e._v("Object")]),e._v("，所以对象使用就需要手动添加"),a("code",[e._v("Iterator")]),e._v("接口；")])])}),[],!1,null,null,null);s.default=r.exports}}]);